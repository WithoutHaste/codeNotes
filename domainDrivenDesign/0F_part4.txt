##Part 4: Strategic Design

"As systems grow too complex to know completely at the level of individual objects, we need techniques for manipulating and comprehending large models."

"[Such design] decisions must be made at team level or even negotiated between teams. These are the decisions where design and politics often intersect."

The challenge is to keep a single, integrated, company-wide model while also breaking in into manageable pieces that can be assigned to different teams.

"A monolithic, all-encompassing domain model will be unwieldy and loaded with subtle duplications and contradictions. A set of small, distinct subsystems glued together with ad hoc interfaces will lack the power to solve enterprise-wide problems and allows consistency problems to arise at every integration point."

#Ch 14: Maintaining Model Integrity

Be wary of re-purposing existing classes to new uses. Especially if the usage is only a /little/ different (as this is the most tempting). It is better to make two distinct classes with clearly defined usages.

Explicitly defining Bounded Contexts will help you keep these almost-duplicated classes apart. Every team may have their own "Charge" class inside their own Bounded Context, and each one can be used differently without confusion.

"Although we seldom think about it explicitly, the most fundamental requirement of a model is that it be internally consistent; that its terms always have the same meaning, and that it contain no contradictory rules...The internal consistency of a model, such that each term is unambiguous and no rules contradict, is called Unification."

"But the world of large systems development is not the ideal world. To maintain that level of unification in an entire enterprise system is more trouble than it is worth...Total unification of the domain model for a large system will not be feasible or cost effective."

"It is necessary to allow multiple models to develop in different parts of the system, but we need to make careful choices about which parts of the system will be allowed to diverge and what their relationship to each other will be...None of this happens by itself or through good intentions. It happens only through conscious design decisions and institution of specific processes."

The cost of having multiple models:
- limits integration
- makes communication more difficult
- is inelegent

The cost of combining all models into one:
- if you refactor too quickly, you'll introduce errors
- the coordination effort can be too onerous to get anything else done
- teams may make compromises that damage their projects
  - either by limiting their own functionality
  - or by making the final model too complicated
- political differences can affect the model
- management priorities can affect the model

It's interesting to see "office politics" given as a reason to divide a model.

"Through a combination of proactive decisions about what should be unified and pragmatic recognition of what is not unified, we can create a clear, shared picture of the situation...We can set about making sure that the parts we want to unify stay that way, and the parts that are not unified don't cause confusion or corruption...We need to chose our strategy consciously and then follow our strategy consistently."

High level overview:
- map the current terrain of the project
- divide the total modal up into Bounded Contexts
- a high level Context Map documents all the Bounded Contexts and how they relate to each other
- practice Continuous Integration to keep all the Bounded Contexts working together
- some closely linked contexts will have a Shared Kernel, others will split apart and go their Seperate Ways

Bounded Contexts

"Cells can exist because their membranes define what is in and out and determine what can pass."

"Different models apply in different contexts."
- integrating with code outside your control probably calls for a different model
- even small projects can generate conflicts over which part of the model is shared and which is not

"Multiple models are in play on any large project...Failure to keep things straight is ultimately revealed when the running code doesn't work right, but the problems starts in the way teams are organized and the way people interact."

"A model applies in a Context. The context may be a certain part of the code, or the work of a particular team. For a model invented in a brainstorming session, the context could be limited to that particular conversation...The model context is whatever set of conditions must apply to in order to be able to say that the terms in a model have a specific meaning."

"Explicitly define the context within which a model applies. Explicitly set boundaries in terms of team organization, usage within specific parts of the application, and physical manifestations such as code bases and database schemas...Keep the model strictly consistent within these bounds, but don't be distracted or confused by issues outside...By drawing an explicit boundary, you can keep the model pure, and therefore potent, where it is applicable."

"In other contexts, other models apply, with differences in terminology, in concepts and rules, and in dialects of the Ubiquitous Language...Integration across the boundaries necessarily will involve some translation, which you can analyze explicitly."
(How is the language Ubiquitous if it has dialects?)

Example: Booking Context (back to the Shipping company)
- if teams do not coordinate carefully and consciously, they will de facto be working in different Contexts
- if the database schema design is driven by the model design, then the database schema is in the same Context
- "This Bounded Context is made up of all those aspects of the system that are driven by this particular model..."
- for the teams in the Bounded Context, they gain clarity
- for the teams outside the Bounded Context, they gain freedom

Recognizing conceptual splinters within a Bounded Context:
- code interfaces that don't match up
- unexpected behavior
- confusion in the language 

Duplicate concepts: you have two model elements (with implementation details) that represent the same concept. Every time one changes, the other has to also.

False cognates: you have one model element being used in two different ways. Usually this happens when two different people/teams are making changes to the same object, and they have slightly different ideas about what that object should do. This leads to difficult-to-discover bugs.

Continuous Integration

"When a number of people [more than two] are working in the same Bounded Context, there is a strong tendency for the model to fragment...Having defined a Bounded Context, we must keep it sound."

"Sometimes developers do not fully understand the intent of some object or interaction modeled by someone else, and they change it in a way that makes it unusable for its original purpose. Sometimes they don't realize that the concepts they are working on are already embodied in another part of the model and they duplicate (inexactly) those concepts and behavior...It is very hard to maintain the level of communication needed to develop a unified system of any size...We need ways of increasing communication and reducing complexity...We also need safety nets that prevent overcautious behavior..."

"Many XP practices are aimed at this specific problem of maintaining a coherent design that is being constantly changed by many people. XP in its purest form is a nice fit for maintaining model integrity within a single Bounded Context."

"...It is essential to have some process of Continuous Integration...[meaning] that all work within the context is being merged and made consistent frequently enough that when splinters happen they are caught and corrected quickly."

Levels of Continuous Integration:
- The integration of model concepts though communication with team members. Constantly practice your Ubiquitous Language.
- The integration of the implementation through an automated merge/build/test process.

Successful Continuous Integration Processes:
- have a step-by-step, reproducible merge/build technique
- have automated testing suites
- have rules that put an upper limit on how long changes can remain unintegrated
- constantly exercise their Ubiquitous Language in discussions of the model and application

"Continuous Integration is essential only within a Bounded Context. Design issues involving neighboring Contexts, including translation, don't have to be dealt with at the same pace."

Context Map

"When connections must be made between different Contexts, they tend to bleed into each other."

"A Context Map is the overlap between project management and software design."

"The Context Map charts the territory, giving the big picture of the Contexts and their connections...The relationships between a Bounded Context and its neighbors require care and attention...You can reduce confusion by defining the relationship between the different Contexts and creating a global view of all the model contexts on the project."

"The natural course of events is for the boundaries to follow the contours of team organization. People who work closely will naturally share a model context...Physical office space can have an impact too...But the interrelationship between team organization and software model and design is still not prominent enough."

"Code reuse between Bounded Contexts is a hazard to be avoided."

"Identify each model in play on the project and define its Bounded Context. This includes implicit models of non-object-oriented subsystems...Name each Bounded Context, and make the name part of the Ubiquitous Language...Describe the points of contact between the models, outlining explicit translation for any communication and highlighting any sharing...Map the existing terrain. Take up transformations later...Whatever form the map takes, it must be shared and understood by everyone on the project."

"Within each Bounded Context, you will have a coherent dialect of the Ubiquitous Language...You can speak unambiguously about the model of any part of the design by making your Context clear."

"[Don't let necessary repair] lead to wholesale reorganization. Until you have an unambiguous Context Map that places all your work into some Bounded Context, with explicit relationships between all connected models, change only the outright contradictions."

Example: Shipping Application with two Contexts
- a new Bounded Context is created so that a difficult operation can use its own data structures and algorithms
- translations at boundaries should be easily testable, and the teams on each side should collaborate on building the test suite

"Model contexts always exist, but without conscious attention they may overlap and fluctuate."

"Contact points with other Bounded Contexts are particularly important to test...Tests help compensate for the subtleties of translation and the lower level of communication that typically exists at boundaries."

Organizing and Documenting Context Maps
- each Bounded Context should have a name that is part of the Ubiquitous Language
- everyone has to know where the Boundaries are; therefore, everyone will know what Context a piece of code is a part of

Ubiquitous Language example:
- instead of saying "George's team's stuff is changing, so we're going to have to change our stuff that talks to it"
- say "the Transport Network model is changing, so we're going to have to change the translator for the Booking context"

The following are some design patterns for how two Bounded Contexts can relate to each other.

Shared Kernel

A Shared Kernel is a Context that is shared by multiple other Contexts. A common example is an infrastructure framework (created by an internal team) which is used by several other teams. Another common example is the Core Domain.

"Designate some subset of the domain model that the two teams agree to share. Of course this includes, along with this subset of the model, the subset of code or of the database design associated that part of the model. This explicitly shared [kernel] has special status, and shouldn't be changed without consultation with the other team."

"It is a careful balance. The shared kernel cannot be changed as freely as other parts of the design. Decisions involve consultation with another team. Automated test suites must be integrated because all tests of both teams must pass when changes are made."

"The goal is to reduce duplication...and make integration between the two subsystems relatively easy."

Customer/Supplier Development Teams

"Often one subsystem essentially feeds another; the 'downstream' component performs analysis or other functions that feed back very little into the 'upstream' component, and all dependencies go one way...The two subsystems commonly serve very different user communities, who do different jobs, where different models may be useful...Upstream and downstream subsystems separate naturally into two Bounded Contexts."

"Translation is easier for having to operate in one direction only."

Possible problems:
- "The freewheeling development of the upstream team can be cramped if the downstream team has veto power over changes, or if procedures for requesting changes are too cumbersome."
- "The upstream team may even be inhibited, worried about breaking the downstream system."
- "The downstream team can be helpless, at the mercy of upstream priorities."
- "Downstream needs things from upstream, but upstream is not responsible for downstream deliverables."

"The process can be organized to balance the needs of the two user communities and schedule work on features needed downstream...On an XP project, there already is a mechanism in place for doing just that: the iteration planning process...Whatever analogous method serves to balance the concerns of different users can be expanded to include the downstream application's needs."

"Establish a clear customer/supplied relationship between the two teams...In planning sessions, make the downstream team play the customer role to the upstream team...Negotiate and budget tasks for downstream requirements so that everyone understands the commitment and schedule."

"Jointly develop automated acceptance tests that will validate the interface expected...This testing will free the upstream team to make changes without fear of side effects downstream...Automating the acceptance tests is a vital part of this customer relationship."

"The relationship must be that of customer and supplier, with the implication that the customer's needs are paramount...[not] the poor-cousin relationship that often emerges, in which the downstream team has to come begging to the upstream team for its needs."

Example: Yield Analysis vs Booking
- teams using different implementation technologies points you more toward Customer/Supplier than Shared Kernel
- analysis vs operations teams often fall into this Customer/Supplier relationship

"Customer/Supplier teams are more likely to succeed if the two teams work under the same management, so that ultimately they do share goals, or where they are in different companies that actually have those roles."

Conformist

"When two development teams have an upstream/downstream relationship in which the upstream has no motivation to provide for the downstream team's needs, the downstream team is helpless...The downstream project will be delayed until the team ultimately learns to live with what it is given."

Options:
- abandon use of the upstream altogether (go your Separate Ways)
- use the upstream, but develop your own model to fix awkwardness or lack on encapsulation - take full responsibility for the translation (see Anti Corruption Layer)
- use the upstream, and use their model (Conformist)

"Eliminate the complexity of translation between Bounded Contexts by slavishly adhering to the model of the upstream team...Choosing conformity enormously simplifies integration...[And] you will share a Ubiquitous Language with your supplier team."

"It is very unappealing emotionally, which is why we choose it less often than we probably should."

"Where the Shared Kernel is a collaboration between two teams that coordinate tightly, Conformist deals with integration with a team that is not interested in collaboration."

Anti Corruption Layer

"Now we'll take a final step to an even more pessimistic view of the relationship, assuming neither cooperation nor a usable design on the other side..."

"New systems almost always have to be integrated with legacy or other systems, which have their own models. Translation layers can be simple, even elegant, when bridging well-designed Bounded Contexts with cooperative teams...But when the other side of the boundary starts to leak through, the translation layer may take on a more defensive tone."

"The models of legacy systems are usually weak, and even the exception that is well developed may not fit the needs of the current project. Yet there may be a lot of value in the integration, and sometimes it is an absolute requirement."

"The answer is not to avoid all integration with other systems...I've been on projects where people enthusiastically set out to replace all the legacy, but this is just too much to take on at once."

"Integrating with existing systems is a valuable form of reuse."

"When systems based on different models are combined, the need for the new system to adapt to the semantics of the other system can lead to a corruption of the new system's own model...It seems clear enough that errors will result if you take some data from one system and misinterpret it in another."

A common mistake is to assume that you understand how to interpret the data from another system.

"Create an isolating layer to provide clients with functionality in terms of their own domain model. The layer talks to the other system through its existing interface, requiring little or no modification to the other system. Internally, the layer translates in both directions as necessary between the two models."

"The public interface of the Anti Corruption Layer usually appears as a set of Services, although occasionally it can take the form of an Entity."

The other system's model can be completely abstracted, and the Anti Corruption Layer can present an interface perfectly aligned with the current system's model.

See also Facades and Adapters, which do not Translate, but can be useful pieces of an Anti Corruption Layer.
"The Facade belongs in the Bounded Context of the other system. It just presents a friendlier face specialized for your needs."
"An Adapter is a wrapper that allows a client to use a different protocol than that understood by the implementer of the behavior."

Example: Legacy Booking Application
- using an Anti Corruption Layer between new and legacy development, and slower replacing pieces of the legacy system with new development

"Although China might not have become so distinct a culture without the Great Wall, the Wall's construction was immensely expensive and bankrupted at least on dynasty, probably contributing to its fall. The benefits of isolation strategies must be balanced against their costs...There is a time to be pragmatic and make measured revisions to the model, so that it can fit more smoothly with foreign ones."

Separate Ways

"Integration can be very valuable, but it is always expensive. We should be sure it is really needed..."

"We must ruthlessly scope requirements. Two sets of functionality with no indispensable relationship can be cut loose from each other."

Problems with integration:
- coordinating teams
- forced compromises - "The simple specialized model that can satisfy a particular need must give way to the more abstract model that can handle all situations."
- limits technology, based on what can integrate together

"Just because features are related in a use case does not mean they must be integrated."

"Therefore, declare a Bounded Context to have no connection to the others at all, allowing developers to find simple, specialized solutions within this small scope...The features can still be organized in middleware or the UI layer, but there will be no sharing of logic, and an absolute minimum of data transfer through translation layers - preferably none."

Example: An Insurance Project Slims Down
- an overwhelmed project simplifies by identifying features that can be delivered as standalone development, that only comes together in the UI menu

"Taking Separate Ways forecloses some options. Although continuous refactoring can eventually undo any decision, it i shard to merge models that have developed in complete isolation."

Open Host Service

"When a subsystem has to be integrated with many others, customizing a translator for each can bog down the team...If there is any coherence to the subsystem, it is probably possible to describe it as a set of Services that cover the common needs of other subsystems."

"Define a protocol [clean enough to be understood and used by multiple teams] that gives access to your subsystem as a set of Services. Open the protocol so that all who need to integrate with you can use it."

If one subsystem needs to integrate with many other systems that are within your control, flip the relationship so that it is the other subsystems that must integrate with you.

If one team has very specific integration needs, write a custom translator for them, and keep your core protocol simple and clean.

Published Language

"The translation between the models of two Bounded Contexts requires a common language."

"When two domain models must coexist and information must pass between them, the translation process itself can become complex and hard to document and understand."

"If we are building a new system, we will typically believe that our new model is the best available, and so we will think in terms of translating directly into it. But sometimes we are enhancing a set of older systems and trying to integrate them. Choosing one messy model over the other may be choosing the less of two evils...Another situation: when businesses want to exchange information with one another, how do they do it? Not only is it unrealistic to expect one to adopt the domain model of the other, it may be undesirable for both parties."

"A domain model is developed to solve problems for its users; such a model may contain features that needlessly complicate communication with another system."

"If the model underlying one of the applications is used as the communications medium, it cannot be changed freely to meet new needs..."

"The Open Host Service uses a standardized protocol for multi-party integration. It employs a model of the domain for interchange between systems, even though the model may not be used internally by those systems."

"By publish, I simply mean that the language is readily available to the community that might be interested in using it, and is sufficiently documented to allow independent interpretations to be comparable."

"Industry groups have begun to form for the purpose of defining a single standard DTD [Document Type Definition] for their industry so that, say, chemical formula information or genetic coding can be communicated between many parties."

Example: A published language for chemistry
- see Chemical Markup Language (CML), a dialect of XML
- XML (and JSON) are sort of published meta-languages

Unifying the Elephant

"If no integration is required, then it doesn't matter that the models are not unified."

"If they require some integration...they will get a lot of value from merely recognizing that they don't agree. This way, at least they don't unknowingly talk as cross-purposes."

"Unifying multiple models almost always means creating a new model."

"...It is the exception when two models purely describe different parts of the whole...Matters are more difficult when two models are looking at the same part in a different way."

"Successful model unification, to a large extent, hinges on minimalism. An elephant trunk is both more and less than a snake, but the less is probably more important than the more. Better to lack the water-spewing ability than to have an incorrect poison-fang feature."

"Recognizing multiple, clashing domain models is really just facing reality...By explicitly defining a context within which each model applies, you can maintain the integrity of each and clearly see the implications of any particular interface you want to create between the two."

Model Context Strategy

"It is important always to draw the Context Map to reflect the current situation at any given time."

It is recommended that teams decide among themselves where to place the boundaries of Bounded Contexts. If the teams don't make those decisions, though, they must at least know what decisions have been made.

"Decisions about whether to expand or to partition Bounded Contexts should be based on the cost-benefit trade-off between the value of independent team action and the value of direct and rich integration."

"In practice, political relationships between teams often determine how systems are integrated. A technically advantageous unification may be impossible because of reporting structure. [Or] management may dictate an unwieldy merger."

Favoring larger Bounded Contexts:
- flow between user tasks is smoother when it is all unified
- team communication is easier with 1 unified model
- it's easier to understand 1 model than 2 models plus the mapping between them
- translating between 2 models can be difficult

Favoring smaller Bounded Contexts:
- lower communication overhead between developers
- continuous integration is easier
- you can use more specific, concrete models instead of versatile, abstract ones
- your can simplify the Ubiquitous Language within a context by putting boundaries between specialized groups that have their own jargon

"Deep integration of functionality between different Bounded Contexts is impractical."

You should generally leave legacy systems and external systems outside your Bounded Context.

Don't assume that each legacy system or external system is 1 Bounded Context. Each system may be made up of many contexts.
"A Bounded Context is defined by an intention to unify the model within certain boundaries."

Integrating with an external system:
- consider Separate Ways, i.e. don't integrate at all. "Would it be sufficient to give the user easy access to both systems? Integration is expensive and distracting, so unburden your project as much as you can."
- consider Conformist, if you are merely extending an existing system. "If you decide on a Conformist design, you must do it wholeheartedly."
- consider Anti Corruption Layer "where your interface to the other system is small, or where the other system is very badly designed."

"The software your project team is actually building is the 'system under design'...You can define Bounded Contexts within this zome and apply Continuous Integration within each to keep them unified."

How many Bounded Contexts should your project use?

"A single Bounded Context for the entire system under design...This would be a likely choice for a team of fewer than ten people working on highly interrelated functionality."

As the team grows larger, you'll divide the space into more and more Bounded Contexts.

"Generally speaking, there is a correspondence of one team per Bounded Context...One team can maintain multiple Bounded Contexts, but it is hard (though not impossible) for multiple teams to work on one together."

Special Needs

"Different groups within the same business have often developed their own specialized terminologies...These local jargons may be very precise and tailored to their needs. Changing them (for example, by imposing a standardized, enterprise-wide terminology) requires extensive training and analysis to resolve the differences...Even then, the new terminology may not serve as well as the finely tuned version they already had."

Specialized jargons is a good reason to create a new Bounded Context. 

The costs of catering to special needs:
- loss of communication because the language is not shared
- the overhead of integration/translation
- some duplication of effort
- "it can become an argument against change and a justification for any quirky, parochial model...how valuable is the particular jargon of this user group?"

"Sometimes a deep model emerges that can unify these distinct languages and satisfy both groups. The catch is that deep models emerge later in the life cycle, after a lot of development and knowledge crunching, if at all. You can't plan on a deep model; you just have to accept the opportunity when it arises, change your strategy, and refactor."

Deployment

"Coordinating the packaging and deployment of complex systems is one of those boring tasks that are almost always a lot harder than they look."

"The choice of Bounded Context strategy has an impact on the deployment...The feasibility of a deployment plan should feed back into the drawing of the context boundaries."

Bounded Contexts that integrate together have to take each other into account when deploying. Which versions have been tested together? Both the code and the data migrations.

With lengthy data migrations and with distributed systems, you often will have two versions of a system in production at once, and they must work together until the deployment is complete.

"The Bounded Context relationships can point you toward the hot spots. The translation interfaces have been marked out."

Discussion of how to slowly convert one type of boundary to another.

#Ch 15: Distillation

"Distillation is the process of separating the components of a mixture to extract the essence in a form that makes it more valuable and useful. A model is a distillation of knowledge. With every refactoring to deeper insights, we abstract some crucial aspect of domain knowledge and priorities."

Strategic distillation of a domain model:
- Aids all team members in grasping the overall design of the system and how it fits together
- Facilitates communication by identifying a core model of manageable size to enter the Ubiquitous Language
- Guides refactoring
- Focuses work on areas of the model with the most value
- Guides outsourcing, use of off-the-shelf components, and decisions about assignments

Core Domain

"A system that is hard to understand is hard to change. The effect of a change is hard to foresee."

"When developers confine their work to specific modules, it further reduces knowledge transfer...smooth integration of the system suffers, and flexibility in assigning work is lost...duplication crops up...so the system becomes even more complex."

"The harsh reality is that not all parts of the design are going to be equally refined...To make the domain model an asset, the model's critical core has to be sleek and fully leveraged to create application functionality."

"Highly skilled developers tend to gravitate to technical infrastructure [projects]...Such parts of the system seem interesting to computer scientists, and are perceived to build transferable professional skills and provide better resume material. The specialized core, that part of the model that really differentiates the application and makes it a business asset, typically ends up being put together by less skilled developers who work with DBAs to create a data schema and then code feature-by-feature without drawing on any conceptual power in the model at all."

(Describing a project) "Most of the strong talent was happily working on database mapping layers and messaging interfaces while the business model was in the hands of developers new to object technology...The single exception, an experienced object developer working on a domain problem, devised a way of attaching comments to any of the long-lived domain objects...Unfortunately, [these features] were peripheral."

"The planning process must drive resources to the most crucial points in the model and design...To do that, these points must be identified and understood by everyone during planning and development."

Core Domain: the parts of the model that are distinctive and central to the purposes of the application

"The Core Domain is where the most value should be added in your system...Make the Core small."

"Apply top talent to the Core Domain, and recruit accordingly...Spend the effort in the Core to find a deep model and develop a supple design - sufficient to fulfill the vision of the system...Justify investment in any other part by how it supports the distilled Core."

"Whenever a choice has to be made (due to time limitations) between two desirable refactorings, the one that most affects the Core Domain should be chosen first."

"The patterns in this chapter make the Core Domain easier to see and use and change."

Choosing the Core

"We are looking at those parts of the model particular to representing your business domain and solving your business problems."

"The Core Domain you choose depends on your point of view...One application's Core Domain is another application's generic supporting component."
Ex: a currency trading application will need a more elaborate view of money than a basic budgeting application.

"...the identification of the Core Domain should evolve through iterations...The importance of a particular set of relationships might not be apparent at first. The objects that seem obviously central at first may turn out to have supporting roles."

Who does the work?

"The most technically proficient members of the project teams seldom have much knowledge of the domain. This limits their usefulness and reinforces the tendency to assign them to supporting components, sustaining a vicious circle in which lack of knowledge keeps them away from the work that would build domain knowledge."

"It is essential to...assemble a team matching up a set of strong developers who have a long-term commitment and an interest in becoming repositories of domain knowledge with one or more domain experts who know the business deeply...It is usually not practical to hire short-term, outside design expertise for the nuts and bolts of creating the Core Domain, because the team needs to accumulate domain knowledge, and a temporary member is a leak in the bucket."

"Domain design is interesting, technically challenging work when approached seriously, and developers can be found who see it this way."

"It is unlikely that the Core Domain can be purchased."
1) a generic solution with resale value is almost antithetical to the idea of a Core Domain
2) you lose the value of having complete control over your Core Domain

If an off-the-shelf framework satisfies part of your design, it indicates that it is not part of the Core Domain.

"One way or another, creating distinctive software comes back to a stable team accumulating specialized knowledge and crunching it in to a rich model. No shortcuts. No magic bullets."

Distillation Techniques (ordered from minimally invasive on up)

Generic Subdomains

"Some parts of the model add complexity without capturing or communicating specialized knowledge...The model clogs up with general principles everyone knows or details that belong to specialties which are not your primary focus but play a supporting role. Yet, however generic, these other elements are essential to the functioning of the system and the full expression of the model."

"There is a part of your model that you would like to take for granted. It is undeniably part of the domain model, but it abstracts concepts that would probably be needed for a great many businesses."
Ex: many businesses need a system for tracking expenses, or for a managerial hierarchy.

"Often a great deal of effort is spent on peripheral issues in the domain...While such components must work, they are not the conceptual core of the system."

"Identify cohesive subdomains that are not the motivation for your project. Factor out generic models of these subdomains and place them in separate modules. Leave no trace of your specialties in them...Give their continuing development lower priority than the Core Domain, and avoid assigning your core developers to the tasks...Also consider off-the-shelf solutions or published models for these Generic Subdomains."

Off-the-shelf Solutions
Pros
- less code for you to write and maintain
- code is probably mature and well tested by many other businesses
Cons
- you have to evaluate many of these products to choose one (or none)
- it probably does contain bugs, and you can't just fix them yourself
- integration may be more trouble than it's worth
- it can introduce platform requirements, such as compiler versions

"Off-the-self subdomain solutions are worth investigating, but they are usually not worth the trouble."

"The more generic the subcomponent, and the more distilled its own model, the better the chance that it will be useful."

Published Design or Model
Pros
- more mature than your new design
- includes insights from many people
- instant, high-quality documentation
Cons
- may not cover your use cases
- may be far over-engineered for your use cases

"This works best when there is a widely distributed model, such as the ones in "Analysis Patterns" by Fowler."

"When the field already has a highly formalized and rigorous model, use it...Accounting and physics are two examples that come to mind. Not only are these very robust and streamlined, but they are widely understood by people everywhere, reducing your present and future training burdens."

Outsource the Implementation
Pros
- your team can focus on the Core Domain
- allows for more development without permanently increasing the team size or losing domain knowledge when the temps leave
- forces an interface-oriented design and encourages the subdomain remain generic
Cons
- your team still needs to contribute to the interface design, coding standards, etc
- incurs significant overhead when handing off the finished work
- code quality will vary

"Automated tests can play an important role in outsourcing...The implementers should be required to provide unit tests for the code they deliver...A really powerful approach is to specify or even write automated acceptance tests for the outsourced components."

In-House Implementation
Pros
- easy integration
- you get exactly the functionality you need
- can be worked on by contractors
Cons
- ongoing maintenance and training
- it is easy to underestimate the time and cost of this approach

"Generic subdomains are the place to try to apply outside design expertise, because they do not require deep understanding of your specialized Core Domain, and they do not present a major opportunity to learn that domain...Confidentiality is less of a concern..."

Example: A Tale of Two Time Zones
"Twice I've watched as the best developers on a project spent weeks of their time solving the problem of storing and converting times with time zones."
One project used basic functionality for as long as possible. Once they clearly saw that they needed more time zone conversion support, they assigned a skilled (but temporary) programmer to the task. He researched existing solutions and, starting from a mature solution, back-filled the rest of the functionality that was needed.
The other project assigned a junior dev to the task before even figuring out the requirements. Not knowing exactly what was needed, the dev set out to handle everything. This was such a difficult task that a senior dev was assigned to help. They wrote complex code with no consumer to verify what was needed, until the project (in general) was canceled. It's possible that complex time zone conversions would never have been needed.
"We technical people tend to enjoy definable problems like time zone conversion, and we can easily justify spending our time on them. But a disciplined look at priorities usually points to the Core Domain."

"Generic doesn't mean reusable...Assuming that you are implementing the code yourself, in-house or outsourced, you should specifically not concern yourself with the reusability of that code. This would go against the basic motivation of distillation: that you should be applying as much of your effort to the Core Domain as possible and investing in supporting Generic Subdomains only as necessary...You do not have to develop the model in its full generality. You can model and implement only the part you need for your business."
So I think "generic" here means "not specialized for our domain", this is supported later when he recommends not incorporating industry-specific objects into the generic model.

"Reuse does happen, but not always code reuse. The model reuse is often a better level of reuse, as when you use a published design or model."

Project Risk Management

"Agile processes typically call for managing risk by tackling the riskiest tasks early. XP specifically calls for getting an end-to-end system up and running immediately...The end-to-end system mitigates risk only to the extent that it is an embryonic version of the challenging parts of the actual system. It is easy to underestimate the domain modeling risk."

"Projects face risks from both sides, with some projects having greater technical risks and others greater domain modeling risks...[The domain modeling risk] can take the form of unforeseen complexity, inadequate access to business experts, or gaps in key skills of the developers...The Core Domain is high risk because it is often unexpectedly difficult and because without it, the project cannot succeed."

"Therefore, except when the team has proven skills and the domain is very familiar, the first-cut system should be based on some part of the Core Domain, however simple."

"The next two patterns...show how the use of supplemental documents can, with a very minor investment, improve communication and awareness of the Core Domain and focus development effort."

Domain Vision Statement

"At the beginning of the project, the model usually doesn't even exist, yet the need to focus its development is already there. In later stages of development, there is a need for an explanation of the value of the system that does not require an in-depth study of the model."

"The critical aspects of the domain model may span multiple Bounded Contexts, but by definition these distinct models can't be structured to show their common focus."

"Many project teams write vision statements for management...Usually the vision statement document is abandoned after the project gets funding..."

"A Domain Vision Statement...focuses on the nature of the domain model and how it is valuable to the enterprise. It can be used...during all phases of development to guide resource allocation. to guide modeling choices, and to educate team members."

"If the domain model serves many masters, this document can show how their interests are balanced."

How to write the Domain Vision Statement:
- write a one page description of the Core Domain, and the value it brings to the company
- only write about the unique/distinct parts of the Domain
- show how the domain model serves and balances diverse interests
- write this early, and keep revising it as you gain new insight

Belongs in the Domain Vision Statement:
- description of things the model needs to represent (Ex: passenger priorities, and membership in special programs)
- description of data that can be provided (Ex: such that audit trails can be provided)
- description of things excluded from the model (Ex: resources required for the process will not be included)
- technical constraints the model must meet (Ex: support efficient routing)
- usability constraints on the model (Ex: the representation of the state of the factory should be comprehensible to human managers)
(pg 416 for full examples)

Doesn't Belong in the Domain Vision Statement:
- anything about the frontend
- anything about framework choices
- anything about architecture choices
- anything about hardware choices

"A Domain Vision Statement gives the team a shared direction."

"A Domain Vision Statement identifies the Core Domain in broad terms, but it leaves the identification of the specific Core model elements up to the vagaries of individual interpretation. Unless there is an exceptionally high level of communication on the team, the Vision Statement alone will have little impact."

Highlighted Core

"Significant structural changes to the code are the ideal way of identifying the Core Domain, but they are not always practical in the short term...Such mahor code changes are difficult to undertake without the very view the team is lacking."

Before you have the Core Domain refactored the way you want it, you need an intermediate way to describe your goal, in more detail than the Domain Vision Statement.

"Even at an advanced stage, a few carefully selected diagrams or documents provide mental anchor points and entry points for the team."

"Any technique that makes it easy for everyone to know the Core Domain will do."

Highlighted Core: The Distillation Document

"A distillation document is not a complete design document. It is a minimalist entry point that delineates and explains the Core Domain and suggests reasons for closer scrutiny of particular pieces."

"The reader is given a broad view of how the pieces fit and guided to the appropriate part of the code for more details."

"Write three to seven sparse pages that describe the Core Domain and the primary interactions among Core Domain elements."
"Write the document to be understood by the nontechnical members of the team."

"It can be as simple as a list of the most essential conceptual objects. It can be a set of diagrams focused on those objects, showing their most critical relationships. It can walk through the fundamental interactions at an abstract level or by example. It can use UML class or sequence diagrams, nonstandard diagrams particular to the domain, carefully worded textual explanations, or combinations of these."

Risks:
- the document is not maintained
- the document is not read
- the document just adds to the complexity of existing documentation

"The best way to limit these risks is to be absolutely minimalist."

"Staying away from mundane detail and focusing on the central abstractions and their interactions allows the document to age more slowly, because this level of the model is usually more stable."

Highlighted Core: The Flagged Core

"On my first day on a project at a major insurance company, I was given a copy of the domain model, a two hundred page document...I went through the document and, with the help of a business analyst who knew a great deal about the insurance industry in general and the requirements of the application we were to build in particular, I identified the handful of sections that presented the essential, differentiating concepts we needed to work with...I provided a navigation of the model that clearly showed the Core and its relationship to supporting features...A new prototyping effort started from this perspective, and quickly yielded a simplified application that demonstrated some of the required functionality."

Whatever form your primary model takes, highlight the Core Domain within it.
"Make it effortless to know what is in or out of the Core."

"If the distillation document outlines the essentials of the Core Domain, then it serves as a practical indicator of the significance of a model change. When a model or code change affects the distillation document, it requires consultation with other team members."

Cohesive Mechanisms

"Hiding complex algorithms in methods with intention revealing names separates the 'what' from the 'how'. This technique makes a design simpler to understand and use."

Sometimes an algorithm is so large and complex that even this is not enough to keep it organized, and clearly reveal its intent.

"A large number of methods that provide algorithms for resolving the problem obscure the methods that express the problem...This proliferation of procedures is a symptom of a problem in the model."

"The first solution to seek is a model that makes the computation mechanism simple. But now that then the insight emerges that some part of the mechanism is itself conceptually coherent...We are not talking about some kind of catch-all calculator. But extracting the coherent part should make the remaining mechanism easier to understand."

"Partition a conceptually Cohesive Mechanism into a separate lightweight framework. Particularly watch for formalisms or well-documented categories of algorithms...[This leaves] a more expressive Core Domain that uses the mechanism through the interface in a more declarative style."

"The model of the Core Domain or Generic Subdomain formulates a fact, rule, or problem. A Cohesive Mechanism resolves the rule or completes the computation as specified by the model."

This separates the Domain from the method used to solve a particular problem.
This allows the complex calculations to be unit tested in isolation.

Ex: A Mechanism in an Organization Chart
Separating well-understood graph theory from application-specific organization chart functionality.

What's the different between a Generic Subdomain and a Cohesive Mechanism?
- a Cohesive Mechanism is totally separated from the Domain model - it just solves a specific algorithmic problem
- a Generic Subdomain is still part of the Domain, but is less important and specialized than the Core Domain

Sometimes a Cohesive Mechanism is actually proprietary information, and is still part of the Core Domain.
When the Cohesive Mechanism provides "a key part of the value of the software."

Ex: Full Circle: Organization Chart Reabsorbs Its Mechanism
Even when a Mechanism is reabsorbed into a Domain, you haven't wasted effort. "The result is usually a deeper model tha more clearly differentiates facts, goals, and Mechanisms."

Distilling to a Declarative Style

"The value of distillation is being able to see what you are doing: cutting to the essence without being distracted by irrelevant detail."

"Important parts of the Core Domain may be able to follow a declarative style, when the supporting design provides an economical language for expressing the concepts and rules of the Core while encapsulating the means of the computing or enforcing them."

"Cohesive Mechanisms are by far the most useful when they provide access through an Intention Revealing Interface, with conceptually coherent Assertions and Side-Effect-Free Functions."

"An exceptional payoff comes when part of the Core Domain itself breaks through to a deep model and starts to function as a language that can express the most important application scenarios flexibly and concisely."

"When a supple design reaches maturity, it provides an easily understood set of elements that can be combined unambiguously to accomplish complex tasks or express complex information, just as words are combined into sentences."

Segregated Core

The "Segregated Core" is the most "Core" part of the "Core Domain". (see Segregating the Core of a Cargo Shipping Model for this clarification)

"You are unlikely ever to find good homes for everything in the Domain model that is not Core."

"Refactor the model to separate the Core concepts from supporting players (including ill-defined ones) and strengthen the cohesion of the Core while reducing its coupling to other code. Factor all generic or supporting elements into other objects and place them into other packages, even if this means refactoring the model in ways that separate highly coupled elements."

"This is basically taking the same principles we applied to Generic Subdomains but from the other direction...Eventually, more and more of the residue can be factored into Generic Subdomains, but in the short term any easy solution will do, just so the focus on the Segregated Core is retained."

Typical steps:
- Identify a Core subdomain
- Move related classes to a new Module, named for the concept that relates them
- Refactor code to sever data and functionality that are not directly expressions of the concept. Put the removed aspects into other packages. Don't waste time being perfect about where you put them.
- Refactor the newly Segregated Core Module to make its relationships and interactions simple and communicative. Minimize its relationships with other Modules.
- Repeat with more Core subdomains

"Segregating the Core will sometimes make relationships with tightly coupled non-Core classes more obscure or even more complicated, but that cost is outweighed by the benefit of clarifying the Core Domain and making it much easier to work on."

"...the greatest value-added of enterprise software comes from the enterprise-specific aspects of the model." So value a cohesive Core Domain over the cohesion of all other parts of the code.

"The time to chop out a Segregated Core is when you have a large Bounded Context that is critical to the system, but where the essential part of the model is being obscured by a great deal of supporting capability."

"As with many strategic design decisions, an entire team must move to a Segregated Core together...This step requires a team decision process and a team disciplined and coordinated enough to carry out the decision...The challenge is to constraint everyone to use the same definition of the Core while not freezing that decision."

"...new insights must be shared with the team on an ongoing basis, but an individual (or programming pair) cannot act on those insights unilaterally. Whatever the process is for joint decisions, whether consensus or team leader directive, it must be agile enough to make repeated course corrections."

Ex: Segregating the Core of a Cargo Shipping Model
Look at the Domain Vision Statement to locate the Core Domain classes. Move everything ancillary to the Vision Statement out of the Core Domain.
The "Segregated Core" is the most "Core" part of the Domain. (I was confused through this whole section about whether the Segregated part was more or less important.)
Some insights are gained during this process, so you may end up with a slightly different set of classes at the end.
Example of dividing Customer from CustomerAgreement (what the Customer wants).

Could you call the two resulting parts the "Segregated Core" and the "Ancillary Core"? Which together form the "Core Domain"?
He also uses the phrase "supporting" several times, so maybe "Supporting Core" instead of "Ancillary Core".

"Recognizing useful, meaning Modules is a modeling activity. Developers and domain experts collaborate in strategic distillation as part of the knowledge crunching process."

Abstract Core

"Even the Core Domain model usually has so much detail that communicating the big picture can be difficult."

"We usually deal with a large model by breaking it into narrower subdomains that are small enough to be grasped and placing them in separate Modules. This reductive style of packaging often works to make a complicated model manageable...But sometimes creating separate Modules can obscure or even complicate the interactions between the subdomains."

"When there is a lot of interaction between subdomains in separate Modules, either many references will have to be created between Modules, which defeats much of the value of the partitioning, or the interaction will have to be made indirect, which makes the model obscure."

"Consider slicing horizontally rather than vertically. Polymorphism gives us the power to ignore a lot of the detailed variation among instances of an abstract type...If most of the interactions across Modules can be expressed at the level of polymorphic interfaces, it may make sense to refactor these types into a special Core Module."

"This is a valuable technique only when the polymorphic interfaces correspond to fundamental concepts in the domain."

"Identify the most fundamental concepts in the model and factor them into distinct classes, abstract classes, or interfaces. Design this abstract model so that it expresses most of the interactions between significant components. Place this abstract overall model in its own Module...Most of the specialized classes will now reference the Abstract Core Module but not the other specialized Modules."

"The Abstract Core gives a succinct view of the main concepts and their interactions."

"The process of factoring out the Abstract Core is not mechanical...Modeling an Abstract Core requires a deep understanding of the key concepts and the roles they play in the major interactions of the system. In other words, it is an example of refactoring to deeper insight. And it usually requires considerable redesign."

Deep Models Distill

"The goal is a design that makes the model obvious, a model that expresses the domain simply."

"A deep model distills the most essential aspects of a domain into simple elements that can be combined to solve the important problems of the application."

Where to Start Refactoring?
Common advice:
- Start anywhere, because it all has to be refactored.
  - DDD: This is impractical. You don't have time to refactor the entire project.
- Start wherever it is hurting you now. Refactor as you need to to complete your current tasks.
  - DDD: This treats symptoms instead of the root causes.
DDD Advice
- Find the root of problem. If it involves the Core Domain, especially if it is a tangled mess you don't want to touch, then bite the bullet and fix it.
- When given free reign, focus on the Core Domain first. Work outward to the Supporting Domain and Generic Subdomains.

"This is how to get the most bang for your refactoring buck."

#Ch 16: Large-Scale Structure

Example of a project with good module breakdown, but so large and complex that this was not sufficient. After much brainstorming and discussion, they devised a set of conceptual layers to organize their project into that made it clear where each part of the project belonged.

"Even with a modular breakdown, a large model can be too complicated to grasp...The modules chunk the design into manageable bites, but there may be too many of them...Modularity does not necessarily bring uniformity to the design. Object to object, package to package, a jumble of design decisions may be applied, each defensible but idiosyncratic."

"In a large system without any overarching principle that allows elements to be interpreted in terms of their role in patterns that span the whole design, developers cannot see the forest for the trees."

"We need to be able to understand the role of an individual part in the whole without delving into the details of the whole."

"A Large Scale Structure is a language that lets you discuss and understand the system in broad strokes. A set of high-level concepts or rules, or both, establishes a pattern of design for an entire system. This organizing principle can guide design as well as aid understanding."

"Devise a pattern of rules or roles and relationships that will span the entire system and that allows some understanding of each part's place in the whole - even without detailed knowledge of the part's responsibility."

"Structure may be confined to one Bounded Context but will usually span more than one...providing the conceptual organization to hold together all the teams and subsystems involved in the project."

"You can't represent most Large Scale Structures in UML, and you don't need to...Most Large Scale Structures shape and explain the model and design but do not appear in it."

"Large Scale Structure can save a project, but an ill-fitting Structure can severely hinder development."

Evolving Order

"To avoid anarchy, projects impose architectures that constrain development in various ways."

"...when architectures start venturing into the arena of the application and domain model, they can create problems of their own. They often prevent the developers from creating designs and models that work well for the specifics of the problem."

"An up-front imposition of a Large Scale Structure is likely to be costly. As development proceeds, you will almost certainly find a more suitable Structure, and you may even find that the prescribed Structure is prohibiting you from taking a design route that would greatly clarify or simplify the application."

"Design free-for-alls produce systems no one can make sense of as a whole, and they are very difficult to maintain. But architectures can straitjacket a project with up-front design assumptions that take too much power away from the developers/designers of particular parts of the application...developers will dumb down the application to fit the structure, or they will subvert it and have no structure at all..."

"The problem is not the existence of guiding rules, but rather the rigidity and source of those rules."

"Let this conceptual Large Scale Structure evolve with the application...Don't over-constrain the detailed design and model decisions that must be made with detailed knowledge."

"Individual parts have natural or useful ways of being organized and expressed that may not apply to the whole, so imposing global rules makes these parts less ideal."

"Choosing to use a Large Scale Structure favors manageability of the model as a whole over optimal structuring of the individual parts...Therefore, there will be some compromise between unifying structure and freedom to express individual components in the most natural way."

"A really nice fit of structure to domain and requirements actually makes detailed modeling and design easier, by helping to quickly eliminate a lot of options."

This chapter speaks about abstract concepts.  Hard to distill it.

"Unlike the Context Map, a Large Scale Structure is optional. One should be imposed when costs and benefits favor it, and when a fitting Structure is found...[good fit means the structure] greatly clarifies the system without forcing unnatural constraints on model development...an ill-fitting Structure is worse than none..."

System Metaphor

The metaphor of a "firewall" has been very useful to defining what features a class of products include, and to help new developers quickly understand the firewall's purpose. But the metaphor is inexact, and also causes some misunderstandings.
Other metaphors: system "layers", a "kernel" at the center of a design

"Software designs tend to be very abstract and hard to grasp. Developers and users alike need tangible ways to understand the system and share a view of the system as a whole."

Systems are shaped by their metaphors because developers will make design decisions based on the metaphor.

"A System Metaphor is a loose, easily understood, Large Scale Structure that is harmonious with the object paradigm."

"Because the System Metaphor is only an analogy to the domain anyway, different models can map to it in an approximate way, which allows it to be applied in multiple Bounded Contexts, helping to coordinate work between them."

"A persuasive Metaphor introduces the risk that the design will take on aspects of the analogy that are not desirable for the problem at hand, or that the analogy, while seductive, may not be apt."

"The System Metaphor should both facilitate communication about the system and guide development of it."

"...a useful Metaphor doesn't present itself on most projects..."

XP programmers use the term "naive metaphor" for the domain model itself. "One trouble with this term is that a mature domain model is anything but naive."

Responsibility Layers

"Layers are partitions of a system in which the members of each partition are aware of and are able to use the services of the layers 'below', but unaware of and independent of the layers 'above'...[Layers] are one of the most successful architectural design patterns."

"In a model with a natural stratification, conceptual layers can be defined around major responsibilities, uniting the two powerful principles of layering and responsibility-driven design...These responsibilities must be considerably broader than those typically assigned to individual objects..."

"Look at the conceptual dependencies in your model and the varying rates and sources of change of different parts of your domain. If you identify natural strata in the domain, cast them as broad abstract responsibilities. These responsibilities should tell a story of the high-level purpose and design of your system. Refactor the model so that the responsibilities of each domain object, Aggregate, and Module fit neatly within the responsibility of one layer."

Example: Layering a Shipping System
Seeing the stratification of the domain: it is easy to discuss A without B, but it is hard to discuss B without A.
The domain is divided into two layers. The decisions on where to put each class are guided by both technical and business concerns.
The layering provides guidance for refactoring towards a deeper model.
The final layers are Capability, Operations, and Decision Support.
"Now, this isn't necessarily a better design than the other. They both have pros and cons. But if everyone on a project makes decisions in a consistent way, the design as a whole will be much more comprehensible, and that is worth some modest trade-offs on detailed design choices."

Choosing Appropriate Layers

"Finding good Responsibility Layers, or any Large Scale Structure, is a matter of understanding the problem domain and experimenting. If you allow Evolving Order, the initial starting point is not critical, although a poor choice does add work."

"As layers get switched out, merged, split, and redefined, here are some useful characteristics to look for and preserve."
- Storytelling: The layers should communicate the basic realities or business priorities of the domain. Choosing a Large Scale Structure is mostly a business modeling decision, not a technical one.
- Conceptual Dependency: The concepts of the upper layers should have meaning against the backdrop of the lower layers. The lower layer concepts should be meaningful standing alone.
- Conceptual Contours: If the objects of different layers should have different rates of change or different sources of change, the layer accommodates the shearing between them.

Some possible layers that are useful in many domains:
- Potential (aka Capability): What can we do? Regardless of what we will actually do. The resources of the organization, including its people, and the way those resources are organized are the core of the Potential layer.
- Operation: What is being done? What have we made of these Potentials? In this layer, we are trying to see our own efforts and activities. What we are selling, rather than what enables us to sell.
- Decision Support: What action should be taken, or policy set? This layer is for analysis and decision making. When projects seek to guide or assist users, or to automate decision making, this is an additional set of responsibilities above Operations.
- Policy: What are the rules and goals? Rules and goals are mostly passive, but constrain the behavior of other layers.
- Commitment: What have we promised? Commitments emerge and change as a part of ongoing business activities (like Operations) but also constrain and guide decisions (like Policy).

Expected rate of change to each layer:
	Decision: almost never
	Policy: slow
	Operation: rapid
	Potential: moderate
	Commitment: moderate

"It is best to keep the layering system simple; going beyond four or possibly five becomes unwieldy."

"Ultimately, you have to use your intuition, start somewhere, and let the Order Evolve."

Knowledge Level

"A Knowledge Level is a group of objects that describes how another group of objects should behave."

"Knowledge Level untangles things when we need to let some part of the model itself be plastic in the user's hands yet constrained by a broader set of rules. It addresses requirements of software with configurable behavior, in which the roles and relationships among Entities must be changed at installation or even at runtime."

Example: Employee Payroll and Pension
Consider a domain where the roles and relationships of objects car vary greatly within one organization over a short period of time. How can the software support this without becoming too complex?
"Neither the fully general objects nor the highly customized ones serve the users' needs." Fully general objects allow the users too much freedom, while highly customized ones must be constantly maintained by the developers.
"Nested in our model is another model that is about our model. A Knowledge Level separates that self-defining aspect of the model and makes its constraints explicit."
This is an application of Reflection - software which is self-aware. This is a meta level.
"Significantly, the pattern is not called a knowledge "layer". As much as it resembles layering, Reflection involves mutual dependencies running in both directions."
Note that the Knowledge Level will not use the reflection built into a programming language. It is operating at a higher level than that.

"The pattern should be used sparingly...Reflection and Knowledge Levels can be intoxicating."

"If the Knowledge Level becomes complex, the system's behavior becomes hard to understand for developers and users alike. The users (or superusers) who configure it will end up needing the skills of a programmer..."

Example: Employee Payroll and Pension II
Designing a Knowledge Level.

(The author must be aware that his language in this chapter is less well defined than before, because he says "large-scale structure" instead of "LARGE-SCALE STRUCTURE". When he has a well-defined phrase, he puts in all caps.)

"At first glance, Knowledge Level looks like a special case of Responsibility Layers, but it is not...dependencies run in both directions between the levels..."

"Knowledge Level can coexist with most other Large Scale Structures, providing an additional dimension of organization."

Pluggable Component Framework

"Distill an Abstract Core of interfaces and interactions and create a framework that allows diverse implementations of those interfaces to be freely substituted. Likewise, allow any application to use those components, so long as it operates strictly through the interfaces of the Abstract Core."

"High-level abstractions are identified and shared across the breadth of the system; specialization occurs in Modules. The central hub of the application is an Abstract Core within a Shared Kernel."

Downsides to a Pluggable Component Framework:
- It is a difficult pattern to apply.
- Applications have limited options.
- It is so expensive to refactor the Core that it's essentially frozen.

"A Pluggable Component Framework should not be the first Large-Scale Structure applied on a project, nor the second."

Example: The SEMATECH CIM Framework
"The interesting thing about it is the definition of a Pluggable Component Framework, which allows people to develop software independently and smoothly integrate them into immense systems."

"How can thousands of people work independently to create a quilt of more than 40,000 panels? A few simple rules provide a Large-Scale Structure for the AIDS Memorial Quilt, leaving the details to the individual contributors...Notice how the rules focus on the overall mission, the features of a component that make integration practical, and the ability to handle the quilt in larger sections."

How Restrictive Should a Structure Be?

"...there is a lot of choice about how restrictive to make the rules."

Discussion of using Events to avoid two-way communication between Layers.
- is this still Layers? using the Events avoids a code dependency, but there is still a conceptual dependency

"A more restrictive structure increases uniformity, making the design easier to interpret. If the Structure fits, the rules are likely to push developers toward good designs."

"On the other hand, the restrictions may take away flexibility that developers need...So you have to fight the temptation to build frameworks and regiment the implementation of the Large Scale Structure."

"The most important contribution of the Large Scale Structure is conceptual coherence, and giving insight into the domain."

"Each Structural rule should make development easier."

Refactoring Toward a Fitting Structure

Structures should not be applied upfront, they should be allowed to grow naturally, as your understanding of the project deepens.

"The team should not saddle itself with a structure conceived of early on, when no one understood the domain or the requirements very well."

"That evolution means that your final structure will not be available at the start, and that means that you will have to refactor to impose it as you go along. This can be expensive and difficult, but it is necessary."

Minimalism

"One key to keeping the cost down is to keep the Structure simple and lightweight. Don't attempt to be comprehensive. Just address the most serious concerns and leave the rest to be handled on a case-by-case basis."

Communication and Self-Discipline

"The entire team must follow the Structure in new development and refactoring. To do this, the Structure must be understood by the entire team."

"Without consistent adherence by the many people involved, Structures have a tendency to decay."

Why is it easy to not follow the Structure?
- It is not usually explicit in the code.
- Functional tests do not rely on it.
- It is often abstract.

"It is critical to incorporate it into the Ubiquitous Language of the project, and for everyone to exercise the Language relentlessly."

Restructuring Yields Supple Design

"Any change to the Structure may lead to a lot of refactoring. The Structure is evolving as system complexity increases and understanding deepens."

"Obviously that is a lot of work [but] this isn't quite as bad as it sounds. I've observed that a design with a Large Scale Structure is usually much easier to transform than one without."

"Part of the answer is that it easier to rearrange something when you can understand its current arrangement...Partly it is that the discipline that it took to maintain the earlier Structure permeates all aspects of the system...But there is something more, I think, because it is even easier to change a system that has had two previous Structures."

"Ever-increasing knowledge is embedded into them and the principal axes of change have been identified and made flexible, while stable aspects have been simplified."

Distillation Lightens the Load

Continue distilling the Domain Model (breaking out Generic Subdomains and such) so that this is less Model that needs Structuring.

The Structure itself may be refactored, such as redefining what Layers your Model is split into.

#Ch 17: Bringing the Strategy Together






#Conclusion
