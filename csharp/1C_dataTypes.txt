##Numerics

#Int

32-bit integer.

#Long

64-bit integer.

#Float

32-bit floating point number. Can hold 7 significant digits.

Cannot accurately store all numbers within its precision range.

#Double

64-bit floating point number - more precise than float. Can hold 15 to 16 significant digits.

Cannot accurately store all numbers within its precision range.

#Decimal

128-bit floating point number - more precise than double. Can hold 28 to 29 significant digits. Comes with slower operations.

Decimal can accurately store any number within its precision range.

#Binary

Binary literal
<code>
public const int Sixteen =   0b00010000;
public const int ThirtyTwo = 0b00100000;
public const int SixtyFour = 0b01000000;
</code>
"0b" prefix indicates a binary number.

#Digit Separator

As of C# 7, you can insert the "_" digit seperator anywhere in a number literal to improve its legibility.

<code>
public const int Sixteen =   0b0001_0000; //base 2
public const long BillionsAndBillions = 100_000_000_000; //base 10
public const double AvogadroConstant = 6.022_140_857_747_474e23; //base 10 decimal places
</code>

(.Net 7.2)

Binary and hexadecimals can have the digit separator right after the prefix:
<code>
public const int Sixteen =   0b_0001_0000; //base 2
</code>

#NaN

NaN: Not a Number

<code>
if(Double.IsNaN(x)
{
}
</code>

#Infinity

<code>
if(Double.IsInfinity(x)) //either negative or positive
{
}
if(Double.IsNegativeInfinity(x))
{
}
if(Double.IsPositiveInfinity(x))
{
}
</code>

##Strings

#Regular string literals

<code>
"string"
"\tstring" //escape character interpreted as Tab
</code>

Escape characters:
single quote \' 
double quote \" 
backslash \\ 
?? \0 \u \U
octal notation \[0-9]+
hex notation \x[0-9a-fA-F]{1,4}
alarm sound \a
backspace \b
formfeed \f
new line \n
carriage return \r
horizontal tab \t
vertical tab \v

#Verbatim string literals

<code>
@"string"
@"\tstring" //the backslash and t are kept as they are
@"quotes""here" //the only escape sequence is two double quotes are interpreted as one
</code>

Verbatim string literals can span multiple lines.

#String Interning

All string literals in your code are compiled into one distinct list to be referenced at runtime, so creating a string literal within a loop will not result in 1000 strings being created - each iteration will reference the same immutable string.

You can add strings to the interning list at runtime. Use this if you expect to use this custom string frequently:
<code>
String.Intern(myCustomString);
</code>

#Composite Formatting

Supported by String.Format, Console.WriteLine, StringBuilder.AppendFormat, TextWriter.WriteLine, Debug.WriteLine, etc.

Note that {0} indicates param index 0. It can be used repeatedly throughout the string, such as "{0} {1} {0} {0}".

Insert text into string based on the index. This is faster than string concatenation when combining four or more strings.
<code>
string s = String.Format("{0} is on the {1} under the {2}", noun1, noun2, noun3);
</code>

Format numbers
<code>
Console.WriteLine("${#,0.00}", amount); //show exactly 2 decimal places, show at least one whole digit, use comma as thousands separator
</code>

Format dates
<code>
Console.WriteLine("{0:MM-dd-yyyy}", DateTime.Now);
</code>

Align text
<code>
Console.WriteLine("{0,10}{1,20}{2,-5}", a, b, c); //number after comma gives width of column, negative number means left-align text
</code>

(I think this is new in C# 6.0, but haven't found confirmation or what it is called)

Using variable name instead of index:
<code>
Console.WriteLine("My name is {@name} and age is {@age}.", name, age);
</code>

#String Formatting

Padding
<code>
string x = "abc".PadLeft(5); //add spaces to beginning of string until length equals 5
</code>

Hexadecimal
<code>
int num = 56;
string upperCaseHex = num.ToString("X");
string lowerCaseHex = num.ToString("x");
string upperCaseHex_2Digits = num.ToString("X2");
string lowerCaseHex_2Digits = num.ToString("x2");

upperCaseHex = String.Format("{0:X}", num);
num = Convert.ToInt32(upperCaseHex, 16);
</code>

Repeat a character x times
<code>
string s = new String('#', x);
</code>

#Interpolated Strings

C# 6.0 and later.

Interpolated strings can contain interpolation expression, surrounded by curly braces {}.
When the string is resolved, each interpolation expression is replaced by its result (as a string).

<code>
$"Hello"
$"Hello, {name}. Today is {DateTime.Now.DayOfWeek}."
</code>

Formatting results:
<code>
$"The time is {DateTime.Now:HH:mm}."
</code>
The "HH:mm" is called the "format string component".

Aligning results:
<code>
$"Columns|{"Left", -7}|{"Right", 7}"
</code>
The integer is the minimum number of characters to show.
Positive means right-aligned in that space, negative means left-aligned.

Special characters:
<code>
$"{{braces}}" //equals "{braces}"
</code>

##Enums

An enum is a distinct type consisting of a set of named constants. They can be declared at the namespace level, or in a class or struct.

Each constant is automatically assigned an integer value, starting from 0 and incrementing by 1.

There is no validation when a value is set. An integer enum will accept any integer value, not just the ones you defined. You have to call Enum.IsDefined to check that explicitly.

<code>
public enum Duration { Daily, Weekly, Monthly };
</code>

You can change the starting integer:
<code>
public enum Duration { Daily=5, Weekly, Monthly };
</code>

You can specify all the values:
<code>
public enum Duration { Daily=5, Weekly=3, Monthly=223 };
</code>

The default datatype is int, but you can also use byte, sbyte, short, ushort, int, uint, long, or ulong.
<code>
public enum Duration : byte { Daily, Weekly, Monthly };
</code>

Enums are frequently used for flags, when you intend to combine several options:
<code>
public enum MessageType { Error=1, Warning=2, Notice=4, Additional=8 };
...
MessageType selectedMessages = MessageType.Warning | MessageType.Notice;
...
private bool IsFlagSet(MessageType flags, MessageType includesValue)
{
	return ((flags & includesValue) == includesValue);
}
</code>
Note that the explicit values are powers of 2. This allows you to use bitwise operators to combine and check the flags.

Converting a string to the enum:
<code>
public enum Duration { Daily, Weekly, Monthly };
Duration e = (Duration)Enum.Parse(typeof(Duration), "Daily");
</code>

##Array

<code>
int[] x = new int[10];
int[] y = new int[] { 1, 2, 3 };
</code>

x64 Platform: array size limited to 2GB

#Multidimensional Arrays

<code>
int[,] x = new int[5,8]; //5 rows, 8 columns each
int[,,]y = new int[5,8,3]; //5 rows, 8 columns each, depth of 3 each

int[,] x = new int[,] {{1,2,3}, {4,5,6}}; //init a [2,3] array
int z = x[1,2]; //z = 6
</code>

To get length of a dimension:
<code>
int rowCount = myArray.GetLength(0);
int colCount = myArray.GetLength(1);
int depthCount = myArray.GetLength(2);
</code>

##List{T}

x64 Platform: generic list size limited to 2GB
Limit can be overridden with <gcAllowVeryLargeObjects enabled="true" />

Lists use a doubling algorithm: if they need more space, the double of their current space will be allocated to them. You can specify how much space they start with when you initialize the list.

##Tuple

C# 4 and above.

A tuple is a data structure containing an ordered sequence of values of (possibly) different types.
Tuples are used where you need a new Type, but don't want to define a new Type.

Tuples can hold up to 8 elements.
Tuples are immutable.
Tuples are references types.

#Accessing

<code>
Tuple<int, string, string> person = new Tuple<int, string, string>(1, "Steve", "Smith");

var person = Tuple.Create(1, "Steve", "Smith");

Console.WriteLine(person.Item1); //outputs 1
Console.WriteLine(person.Item2); //outputs Steve
</code>

The 8th element is saved (by default) as a tuple.
<code>
var nums = Tuple.Create(1, 2, 3, 4, 5, 6, 7, 8);

Console.WriteLine(nums.Item7); //outputs 7
Console.WriteLine(nums.Rest); //outputs (8)
Console.WriteLine(nums.Rest.Item1); //outputs 8
</code>

You can nest tuples inside tuples to store more than 8 elements.
Recommendation: don't. Create a proper Type for this data.

#Parameter

You can have tuple parameters.

<code>
public void MyMethod(int x, Tuple<int, string, string> y)
{
}
</code>

#Return

You can return tuples.
This is a way to return multiple values without a specific Type, nor by using out, nor ref.

<code>
var x = MyMethod();

public Tuple<int, string, string> MyMethod()
{
	return Tuple.Create(1, "Steve", "Smith");
}
</code>

#Deconstruct

This is called deconstructing a tuple.
It breaks a tuple's values into separate variables.

<code>
var (age, name) = MyMethod();

(int age, string name) = MyMethod();

int age;
string name;
(age, name) = MyMethod();
</code>

As of C# 7, you can ignore some tuple elements while destructuring by using the "discard" operator "_".
<code>
public Tuple<int, string, int, string, string> MyMethod()
{
	return (1, "TX", 23, "Engineer", "Smith");
}

var (_, _, age, _, name) = MyMethod();
</code>

As of C# 7.1, tuple element names will default to the names of variable arguments:
<code>
int age = 23;
string name = "Smith";
var person = (age, name);
Console.WriteLine(person.name); //outputs Smith
</code>

#C# 7 ValueTuple

A ValueTuple is a value-type Tuple.

Support named members:
<code>
(int age, string name) person = (23, "Smith");

var person = (age: 23, name: "Smith");

Console.WriteLine(person.name); //outputs Smith
</code>
Unnamed members can still be accessed by ".Item1" etc.

Return:
<code>
static (int, string) MyMethod()
{
	return (23, "Smith");
}

var (age, name) = MyMethod();

Console.WriteLine(name); //outputs Smith
</code>
<code>
static (int age, string name) MyMethod()
{
	return (23, "Smith");
}

var person = MyMethod();

Console.WriteLine(name); //outputs Smith
</code>