##Int

##Float

32-bit floating point number. Can hold 7 significant digits.

Cannot accurately store all numbers within its precision range.

##Double

64-bit floating point number - more precise than float. Can hold 15 to 16 significant digits.

Cannot accurately store all numbers within its precision range.

#NaN

NaN: Not a Number

<code>
if(Double.IsNaN(x)
{
}
</code>

#Infinity

<code>
if(Double.IsInfinity(x)) //either negative or positive
{
}
if(Double.IsNegativeInfinity(x))
{
}
if(Double.IsPositiveInfinity(x))
{
}
</code>

##Decimal

128-bit floating point number - more precise than double. Can hold 28 to 29 significant digits. Comes with slower operations.

Decimal can accurately store any number within its precision range.

##Strings

#Regular string literals

<code>
"string"
"\tstring" //escape character interpreted as Tab
</code>

Escape characters:
single quote \' 
double quote \" 
backslash \\ 
?? \0 \u \U
octal notation \[0-9]+
hex notation \x[0-9a-fA-F]{1,4}
alarm sound \a
backspace \b
formfeed \f
new line \n
carriage return \r
horizontal tab \t
vertical tab \v

#Verbatim string literals

<code>
@"string"
@"\tstring" //the backslash and t are kept as they are
@"quotes""here" //the only escape sequence is two double quotes are interpreted as one
</code>

Verbatim string literals can span multiple lines.

#String Interning

All string literals in your code are compiled into one distinct list to be referenced at runtime, so creating a string literal within a loop will not result in 1000 strings being created - each iteration will reference the same immutable string.

You can add strings to the interning list at runtime. Use this if you expect to use this custom string frequently:
<code>
String.Intern(myCustomString);
</code>

#String Formatting

for String.Format or Console.WriteLine

Insert text into string based on the index. This is faster than string concatenation when combining four or more strings.
<code>
string s = String.Format("{0} is on the {1} under the {2}", noun1, noun2, noun3);
</code>

Format numbers
<code>
Console.WriteLine("${#,0.00}", amount); //show exactly 2 decimal places, show at least one whole digit, use comma as thousands separator
</code>

Format dates
<code>
Console.WriteLine("{0:MM-dd-yyyy}", DateTime.Now);
</code>

Align text
<code>
Console.WriteLine("{0,10}{1,20}{2,-5}", a, b, c); //number after comma gives width of column, negative number means left-align text
</code>

Padding
<code>
string x = "abc".PadLeft(5); //add spaces to beginning of string until length equals 5
</code>

Hexadecimal
<code>
int num = 56;
string upperCaseHex = num.ToString("X");
string lowerCaseHex = num.ToString("x");
string upperCaseHex_2Digits = num.ToString("X2");
string lowerCaseHex_2Digits = num.ToString("x2");

upperCaseHex = String.Format("{0:X}", num);
num = Convert.ToInt32(upperCaseHex, 16);
</code>

Repeat a character x times
<code>
string s = new String('#', x);
</code>

##Enums

An enum is a distinct type consisting of a set of named constants. They can be declared at the namespace level, or in a class or struct.

Each constant is automatically assigned an integer value, starting from 0 and incrementing by 1.

There is no validation when a value is set. An integer enum will accept any integer value, not just the ones you defined. You have to call Enum.IsDefined to check that explicitly.

<code>
public enum Duration { Daily, Weekly, Monthly };
</code>

You can change the starting integer:
<code>
public enum Duration { Daily=5, Weekly, Monthly };
</code>

You can specify all the values:
<code>
public enum Duration { Daily=5, Weekly=3, Monthly=223 };
</code>

The default datatype is int, but you can also use byte, sbyte, short, ushort, int, uint, long, or ulong.
<code>
public enum Duration : byte { Daily, Weekly, Monthly };
</code>

Enums are frequently used for flags, when you intend to combine several options:
<code>
public enum MessageType { Error=1, Warning=2, Notice=4, Additional=8 };
...
MessageType selectedMessages = MessageType.Warning | MessageType.Notice;
...
private bool IsFlagSet(MessageType flags, MessageType includesValue)
{
	return ((flags & includesValue) == includesValue);
}
</code>
Note that the explicit values are powers of 2. This allows you to use bitwise operators to combine and check the flags.

Converting a string to the enum:
<code>
public enum Duration { Daily, Weekly, Monthly };
Duration e = (Duration)Enum.Parse(typeof(Duration), "Daily");
</code>

##Array

<code>
int[] x = new int[10];
int[] y = new int[] { 1, 2, 3 };
</code>

x64 Platform: array size limited to 2GB

#Multidimensional Arrays

<code>
int[,] x = new int[5,8]; //5 rows, 8 columns each
int[,,]y = new int[5,8,3]; //5 rows, 8 columns each, depth of 3 each

int[,] x = new int[,] {{1,2,3}, {4,5,6}}; //init a [2,3] array
int z = x[1,2]; //z = 6
</code>

To get length of a dimension:
<code>
int rowCount = myArray.GetLength(0);
int colCount = myArray.GetLength(1);
int depthCount = myArray.GetLength(2);
</code>

##List<T>

x64 Platform: generic list size limited to 2GB
Limit can be overridden with <gcAllowVeryLargeObjects enabled="true" />

Lists use a doubling algorithm: if they need more space, the double of their current space will be allocated to them. You can specify how much space they start with when you initialize the list.