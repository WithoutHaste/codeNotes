##Constructs

#Classes

Classes define reference-types.
Classes can contain any type of member.
Classes can define the implementation of any type of member.
Classes that are not abstract nor static can be instantiated.

#Interfaces

Interfaces can contain the signatures of methods, properties, events, or indexes.
Interfaces cannot define the implementation of any type of member.
Interfaces cannot be instantiated.

Interfaces cannot contain static members.
Interface members are implicitly public.

When defining Property signatures, an interface can define read and/or write accessibility by including the get and/or set accessor.

Interfaces can be internal. If so, all its members will also be internal.
Interfaces can be declared within a class.

(.Net 8)

Interfaces can define default implementations of their methods.
These default can be overridden by the implementing class.

The intent is that API authors can add more methods to an in-use interface without forcing all users to immediately update their code.

Note that Classes that implement from Interfaces with default implementations DO NOT inherit the implementations.
Thus, the allowance for inheriting from multiple Interfaces continues.
What happens is that the consumer may cast their instance of the Class to the Interface type to access the default implementation.
And there is no compilation error that the new method has not been implemented in the inheriting Class.
- Tested and verified this is how it works, despite conflicting articles from Microsoft.

<code>
public interface IInterface
{
	int Random(int a, int b)
	{
		return a + b;
	}
	
	int Subtract(int a, int b);
}

public class MyClass : IInterface
{
	public MyClass()
	{
	}

	public int Subtract(int a, intb)
	{
		return a - b;
	}
}

MyClass instance = new MyClass();
Console.WriteLine(instance.Subtract(10, 2)); //outputs 8
Console.WriteLine(instance.Random(10, 2)); //compilation error
Console.WriteLine((instance as IInterface).Random(10, 2)); //outputs 12
</code>

To override a default interface implementation:
<code>
public class MyClass : IInterface
{
	public MyClass()
	{
	}

	public int Subtract(int a, intb)
	{
		return a - b;
	}
	
	//Note that the override keyword is not used
	public int Random(int a, int b)
	{
		return 4;
	}
}
</code>
You cannot call back to the default implementation, the way you could call back to a base class's implementation.

Interfaces can also now include Static Members to better support this new use case.
Interfaces can also now include Access Modifiers to better support this new user case.

Example of providing a default implementation with settings to make it more widely useful:
<code>
private static TimeSpan length = new TimeSpan(365 * 2, 0,0,0); // two years
private static int orderCount = 10;
private static decimal discountPercent = 0.10m;

public static void SetLoyaltyThresholds(TimeSpan ago, int minimumOrders = 10, decimal percentageDiscount = 0.10m)
{
	length = ago;
	orderCount = minimumOrders;
	discountPercent = percentageDiscount;
}

public decimal ComputeLoyaltyDiscount() => DefaultLoyaltyDiscount(this);
protected static decimal DefaultLoyaltyDiscount(ICustomer c)
{
	DateTime start = DateTime.Now - length;
	if ((c.DateJoined < start) && (c.PreviousOrders.Count() > orderCount))
	{
		return discountPercent;
	}
	return 0;
}
</code>

Example use case of enabling object composition:
<code>
interface ILight ...
interface ITimerLight : ILight ...
interface IBlinkingLight : ILight ...

public class LedLight : IBlinkingLight, ITimerLight, ILight
{
}
</code>

#Structs

Structs define value-types (saved in Stack Memory).
...If a struct is stored as a property in a class, it will be stored on the heap with the rest of the object.
Structs cannot define explicit parameterless constructors.
Structs cannot define default field values.
Struct field/properties do not have to be immutable, but that is a common use case.

You cannot set a custom default value for a struct. The default is always "all fields/properties set to their default values".

(.Net 4.6)

Structs can now define explicit parameterless constructors.

(.Net 7.2)

Structs can now be declared readonly. This is now an immutable data type.
<code>
public readonly struct Point
{
	//...
}
</code>

Ref Structs are allocated to stack memory, never to heap memory
Limits:
- cannot be used as the element type of an array
- cannot be used as a field type in a class or non-ref struct
- cannot implement interfaces
- cannot be boxed to System.ValueType or System.Object
- cannot be a type argument
- cannot be captured by a lambda or local function (function nested in another member)
- cannot be used in an async method, but can be used by synchronous methods that return Task or Task<Result>
- cannot be used in iterators
<code>
public ref struct MyStruct
{
	public bool IsValid;
    public Span<int> Inputs; //Span<T> can be used within a ref struct
    public Span<int> Outputs;
}
</code>

Ref structs can be declared readonly
<code>
public readonly ref struct MyStruct
{
}
</code>

(.Net 8)

Mark methods as readonly if they do not modify the state of the struct.
<code>
public readonly override string ToString()
{
	return $"({X}, {Y}) is {Distance} from the origin";
}
</code>
You'll get a compiler warning if a readonly method accesses a non-readonly method or property accessor.

Mark properties as readonly if they never change state.
The compiler does not assume that Get accessors do not change state, so not having a Set accessor is insufficient.
<code>
public readonly double Distance => Math.Sqrt(X * X + Y * Y);
</code>
The compiler will assume that all auto-generated Get accessors are readonly.

The compiler enforces the rule that readonly members do not alter state.

(C# 10)
Non-Destructive Mutation
<code>
public readonly struct MyStruct
{
    public double X { get; set; }
    public double Y { get; set; }
}

public static void Main()
{
    var a = new MyStruct() { X = 1, Y = 2 };
    var b = a with { X = 3 }; //creates a copy with X=3, Y=2
    var c = b with { X = 4, Y = 5 }; //creates a copy with X=4, Y=5
}
</code>

Record Struct
record structs cannot also be ref structs

(C# 11)
Structs can include ref fields.
Ref fields can have value Null even if they are value types like Int.
<code>
public ref struct MyStruct
{
	private ref int number;
	public int GetNumber()
	{
		if (System.Runtime.CompilerServices.Unsafe.IsNullRef(ref number)) //check for null value
		{
			throw new InvalidOperationException("The number ref field is not initialized.");
		}
		return number;
	}
}
</code>

(C# 11)
The compiler will ensure that all fields of a struct type are initialized to their default value as part of executing a constructor.

(C# 12)
Inline Arrays aka Fixed Sized Buffers
- a structure that contains a contiguous block of N elements of the same type
- a safe-code equivalent of the fixed buffer declaration
- a struct that contains a single field and does not specify an explicit layout
- can usually be accessed like an array to read and write
- can use the range and index operators

This is an advanced language feature, intended for high-performance scenarios where an inline, contiguous block of elements is faster than other alternative data structures.

<code>
[System.Runtime.CompilerServices.InlineArray(10)]
public struct CharBuffer
{
	private char _firstElement; //cannot be a pointer type, can be a reference or value type
}
</code>

#Records

(available in C# 9, which means you need .NET 6 or later)

A reference type.
Use value-based equality (unlike classes).

To support value-based comparisons, a record will automatically generate these methods for you: Object.Equals(Object), Equals(T recordType), Object.GetHashCode(), ==, !=, System.IEquatable<T>, Object.ToString()

<code>
public record Widget {
	public string Name { get; set; }
}
</code>

Optional: be clear that this is a reference type
<code>
public record class Widget {
	public string Name { get; set; }
}
</code>

#Record Structs

(available in C# 10)

Records as a value type.

<code>
public record struct Widget {
	public string Name { get; set; }
}
</code>

##Inheritance

#Classes

C# only allows a class to inherit from a single other class.
This avoids ambiguous cases like loops in the inheritance tree, when class D derives from B and C, with B and C both deriving from A.

If class B derives from class A, note that casting a B object to type A does not block usage of the B-specific functionality. It can always be cast back to type B.

<code>
class MyClass
{
	private List<string> list = new List<string>();
	
	public IEnumerable<string> MyStrings
	{
		//casting to IEnumerable does not protect your list from editing
		get { return list; }
	}
}
</code>

#Method Overriding

Overriding instance methods:
<code>
class A
{
	public virtual void MyMethod()
	{
	}
}

class B : A
{
	public override void MyMethod()
	{
	}
}
</code>

Overriding static methods:
<code>
class A
{
	public static void MyMethod()
	{
	}
}

class B : A
{
	public static new void MyMethod()
	{
	}
}
</code>

#Interfaces

A class can inherit from any number of interfaces, because they are just a list of member signatures.

Interfaces can also inherit from interfaces.

Explicit Interface Implementation:
When a class implements more than one interface with members of the same name, you can explicitly state which member is from which interface.
<code>
string IEmployee.Name
{
	get { return _name; }
}
</code>
Explicit interface implementations cannot be declared public, and they can only be called when the object is cast to that interface type.
It can differentiate between properties, between methods, or between a property and method with a shared name.

#Structs

Structs cannot inherit from classes or structs.
