##Part 2

#Preface: The Building Blocks of Model Driven Design

"Certain kinds of decisions keep the model and implementation aligned with each other, each reinforcing the other's effectiveness. This alignment requires attention to the details of individual elements."

"The design style in this book largely follows the principle of Responsibilty Driven Design...and Design By Contract."

"Elaborate models can cut through complexity only if care is taken with the fundementals, rsulting in detailed elements that the team can confidently combine."

#Ch 4 Isolating the Domain

"The part of the software the specifically solves problems from the domain usually constitutes only a small portion of the entire software system...We need to decouple the domain objects from other functions of the system, so we can avoid confusing the domain concepts with other concepts related only to software technology or losing sight of the domain altogether in the mass of the system."

See Layered Architecture / Onion Architecture / Clean Architecuture.
Briefly, isolate the domain logic and don't make it dependent on any other part of the system.

Discussion of when it is appropriate to not use Layered Architecture: fast, simple projects with non-expert developers. See Smart UI Pattern.

#Ch 5 A Model Expressed in Software

"Associations between objects are simple to conceive and to draw, but implementing them is a potential quagmire...Associations illustrate how crucial detailed implementation decisions are to the viability of a Model Driven Design."

Patterns of model elements:
- Value Object
- Entity
- Service

An Entity has a identity that has continuity even as the state of the object changes, even if all its data changes. An Entity's identity may stretch across multiple systems and representations.

A Value Object merely describes an attribute, a value. They could all be immutable without affecting the system.

Services express actions or operations. Services perform operations upon request. These are the operations that don't make sense inside your Entities or Value Objects. These operations need to be done, but they don't correspond with State.

"A sense of the basic principles will help developers stay on course through the inevitable compromises."

Design Principle: "For every traversable association in the model, there is a mechanism in the software with the same properties."

"It is important to restrain relationships as much as possible...In real life, there are lots of many-to-many associations, and a great number are naturally bidirectional. The same tends to be true of early forms of a model as we brainstorm and explore the domain. But these general associations complicate implementation and maintentance. Furthermore, they communicate very little about the nature of the relationship...A bidirectional association means that both objects can be understood only together."

Options to replace a many-to-many relationship:
1) Impose a 1-to-many relationship on it
2) Reduce multiplicity by adding a condition/filter/qualifier to the relationship
3) Remove it entirely if it is non-essential

"This refinement actually reflects insight into the domain, as well as making a more practical design...It captures the understanding that one direction of the association is much more meaningful and important than the other."
Ex: Country <-> President is bidirectional, but we rarely ask "Which country was X president of?" and we rarly say "Y was president of both A and B countries." So we can simplify this relationship to Country -> President.

Entity vs Value Object example:
At a bank, two transactions on the same day, for the same account, for the same amount are Entities because they are distinct from each other despite appearing similar.
The amount of those transactions is a Value Object, because there is no usefullness in distinguishing them from each other or tracking their indentities across time.

Design Principle: Provide all Entities with a way to compare their identity regardless of current state or history. Most commonly, this will be a unique key.

"Identity is not intrinsic to a thing in the world; it is a meaning superimposed because it is useful."

The common theme for these decisions is "what is useful to our purpose?"

"[When modeling Entities,] strip the Entity object's definition down to the most intrinsic characteristics, particularly those that identify it or are commonly used to find or match it. Add only behavior that is essential to the concept and attributes that are required by that behavior. Beyond that, look to remove behavior and attributes into other objects associated with the core Entity...Entities tend to fulfill their responsibilities by coordinating the operations of objects they own."

"[Value Objects] are the objects that describe things...An object that represents a descriptive aspect of the domain with no conceptual identity is called a Value Object...We care about what they are, but not who/which they are."

Example of when an Address is a Value Object: The domain is a mail-order company. It needs your address for your parcel. But if your roommate also places an order, it is not important to realize that the two addresses are the same.

Example of when an Address is an Entity: The domain is an electrical company that runs lines to houses/businesses. They do need to realize that both roommates at the same addresses put in an order. (In this case, maybe the Entity is a "Dwelling" which has a Value Object "Address". There are many ways to organize a domain model.)

Value Objects can be made up of other objects. They do not have to be a primitives like a String or Int.
Value Objects can include references to Entities. Ex: a driving route (Value Object) that links two locations (Entities).
Value Objects are frequently transient (never saved in long-term memory).
Value Objects are frequently attributes of Entities.

"The attributes that make up a Value Object should form a conceptual whole. For example, street, city, and postal code shouldn't be separate attributes of a Person object. They are part of a single, whole Address, which makes a simpler Person, and more coherent Value Object."

Why Value Objects should be Immutable:
- Memory can be conserved by sharing Value Objects without risking data corruption.
  - Ex: PersonA and PersonB share a Name. PersonA edits their Name by instantiating a new Name object, so that PersonB's Name is not affected.
  - A lot of memory can be used up by repeated Value Objects. For instance, imagine every Electrical Outlet in a Floor Plan was a unique object instead of one shared object.
- Value Objects can be passed as arguments without worrying about unintended side effects.
  - Ex: PersonA passes their Name into a method. They know the method will not edit the Name because it cannot.

Not all the constraints we define in the model can be enforced with the programming language we are using. In these cases, you must rely on conventions, good naming standards, and good communication.

The associations between Value Objects should be kept simple for the same reasons as for Entities.
With the addendum that there is never a reason to have a bi-directional association between Value Objects. If you're sure you need one, they are probably actually Entities.

"Some concepts from the domain aren't natural to model as objects."
Services are for domain operations that have no proper Entity to belong to.
Services frequently orchestrate interactions between many Entities at once.
Services must be stateless - they can change the state of the system, but must not keep any internal state.
Services are named for verbs instead of for nouns.
- Operation names should still be a part of the ubiquitous language.
- Parameters and results should be domain objects.

"Now, the more common mistake is to give up too easily on fitting the behavior into an appropriate object, gradually slipping towards procedural programming. But when we force an operation into an object that doesn't fit the object's definition, the object loses its conceptual clarity and becomes hard to understand or refactor...Complex operations can easily swamp a simple object, obscuring its role."

"Services should be used judiciously and not allowed to strip the Entities and Value Objects of all their behavior."

Where is the division between Application Services and Domain Services?
Ex: Giving banking software
- ExportReportToCSV is an Application Service because it involves concepts (like file format) that do not exist in the banking domain and does not involve any business rules.
- TransferMoneyBetweenAccounts is a Domain Service because it heavily involves banking domain concepts and business rules.

Domain Services can become a useful medium-grained layer between the application and the fine-grained Entity objects of the domain.
They can form a set of use cases, and can keep business rules from creeping into the application layer.

Modules (aka Packages aka Assemblies) are both a technical division of code, and a conceptual division of the design.
If the domain is divided into multiple Modules, take care that the resulting Modules have low coupling between them and high cohesion within them.
Modules that are divided well will reduce the mental strain of working in the Modules, because they will have low coupling between them, so you can focus on one small part of the code at a time.

"Modules and the smaller elements should coevolve, but typically they do not. Modules are chosed to organize an early form of the objects. After that, the objects tend to change in ways that keep them in the bounds of the existing Module definition...Even developers who refactor a lot tend to content themselves with Modules conceived early in the project...Refactoring Modules is more work and more disruptive than refactoring classes, and probably can't be as frequent. But just as Model Objects tend to start out naive and concrete and then gradually transform to reveal deeper insight, Modules can become subtle and abstract."

"Like everything else in a domain-driven design, Modules are a communications mechanism. The meaning of the objects being partitioned needs to drive the choice of the Modules. When you place some classes together in a Module, you are telling the next developer who looks at your design to think about them together."

If you must make trade-offs between conceptual cohesion and technical cohesion, choose greater conceptual clarity. The technical difficulties can be handled when the story the code tells is understandable.

Some frameworks or infrastructures impose module divisions on a project. Do not allow this to complicate your domain. It is more important to have an easily comprehended domain than to follow a particular framework's rules.

Object-oriented programming is a good choice because:
- Objects and relationships correlate well with the domain model.
- It has been proven over time to be easily comprehended by both technical and non-technical people.
- It is widely understood, so you can find experienced programmers.
- There are many support and integration tools already in existance.

A good bit of talk about the usefullness of sticking with Model Driven Design, despite technical obstacles.

"Although a Model Driven Design does not have to be object oriented, it does depend on having an expressive implementation of the model constructs...If the available tool does not facilitate that expressiveness, reconsider the choice of tools...An unexpressive implementation negates the advantage of the extra paradigm."

Rules of thumb for mixing non-object elements into an object-oriented system:
- Don't fight the implementation paradigm. "There's always another way to think about a domain. Find model concepts that fit the paradigm."
- Lean on the ubiquitous language. "Even when there is no rigorous connection between tools, very consistent use of language can keep parts of the design from diverging."
- Don't get hung up on UML. "Sometimes the fixation on a tool, such as UML diagramming, leads people to distort the model to make it fit what can easily be drawn."
- Be skeptical. "Is the tool really pulling its weight? Just because you have some rules, that doesn't necessarily mean you need the overhead of a rules engine."

"Before taking on the burden of mixed paradigms, the options within the dominant paradigm should be exhausted...Even though some domain concepts don't present themselves as obvious objects, they often can be modeled within the paradigm."

#Ch 6 The Life Cycle of a Domain Object

