##Part 4: Strategic Design

"As systems grow too complex to know completely at the level of individual objects, we need techniques for manipulating and comprehending large models."

"[Such design] decisions must be made at team level or even negotiated between teams. These are the decisions where design and politics often intersect."

The challenge is to keep a single, integrated, company-wide model while also breaking in into manageable pieces that can be assigned to different teams.

"A monolithic, all-encompassing domain model will be unwieldy and loaded with subtle duplications and contradictions. A set of small, distinct subsystems glued together with ad hoc interfaces will lack the power to solve enterprise-wide problems and allows consistency problems to arise at every integration point."

#Ch 14: Maintaining Model Integrity

Be wary of re-purposing existing classes to new uses. Especially if the usage is only a /little/ different (as this is the most tempting). It is better to make two distinct classes with clearly defined usages.

Explicitly defining Bounded Contexts will help you keep these almost-duplicated classes apart. Every team may have their own "Charge" class inside their own Bounded Context, and each one can be used differently without confusion.

"Although we seldom think about it explicitly, the most fundamental requirement of a model is that it be internally consistent; that its terms always have the same meaning, and that it contain no contradictory rules...The internal consistency of a model, such that each term is unambiguous and no rules contradict, is called Unification."

"But the world of large systems development is not the ideal world. To maintain that level of unification in an entire enterprise system is more trouble than it is worth...Total unification of the domain model for a large system will not be feasible or cost effective."

"It is necessary to allow multiple models to develop in different parts of the system, but we need to make careful choices about which parts of the system will be allowed to diverge and what their relationship to each other will be...None of this happens by itself or through good intentions. It happens only through conscious design decisions and institution of specific processes."

The cost of having multiple models:
- limits integration
- makes communication more difficult
- is inelegent

The cost of combining all models into one:
- if you refactor too quickly, you'll introduce errors
- the coordination effort can be too onerous to get anything else done
- teams may make compromises that damage their projects
  - either by limiting their own functionality
  - or by making the final model too complicated
- political differences can affect the model
- management priorities can affect the model

It's interesting to see "office politics" given as a reason to divide a model.

"Through a combination of proactive decisions about what should be unified and pragmatic recognition of what is not unified, we can create a clear, shared picture of the situation...We can set about making sure that the parts we want to unify stay that way, and the parts that are not unified don't cause confusion or corruption...We need to chose our strategy consciously and then follow our strategy consistently."

High level overview:
- map the current terrain of the project
- divide the total modal up into Bounded Contexts
- a high level Context Map documents all the Bounded Contexts and how they relate to each other
- practice Continuous Integration to keep all the Bounded Contexts working together
- some closely linked contexts will have a Shared Kernel, others will split apart and go their Seperate Ways

Bounded Contexts

"Cells can exist because their membranes define what is in and out and determine what can pass."

"Different models apply in different contexts."
- integrating with code outside your control probably calls for a different model
- even small projects can generate conflicts over which part of the model is shared and which is not

"Multiple models are in play on any large project...Failure to keep things straight is ultimately revealed when the running code doesn't work right, but the problems starts in the way teams are organized and the way people interact."

"A model applies in a Context. The context may be a certain part of the code, or the work of a particular team. For a model invented in a brainstorming session, the context could be limited to that particular conversation...The model context is whatever set of conditions must apply to in order to be able to say that the terms in a model have a specific meaning."

"Explicitly define the context within which a model applies. Explicitly set boundaries in terms of team organization, usage within specific parts of the application, and physical manifestations such as code bases and database schemas...Keep the model strictly consistent within these bounds, but don't be distracted or confused by issues outside...By drawing an explicit boundary, you can keep the model pure, and therefore potent, where it is applicable."

"In other contexts, other models apply, with differences in terminology, in concepts and rules, and in dialects of the Ubiquitous Language...Integration across the boundaries necessarily will involve some translation, which you can analyze explicitly."
(How is the language Ubiquitous if it has dialects?)

Example: Booking Context (back to the Shipping company)
- if teams do not coordinate carefully and consciously, they will de facto be working in different Contexts
- if the database schema design is driven by the model design, then the database schema is in the same Context
- "This Bounded Context is made up of all those aspects of the system that are driven by this particular model..."
- for the teams in the Bounded Context, they gain clarity
- for the teams outside the Bounded Context, they gain freedom

Recognizing conceptual splinters within a Bounded Context:
- code interfaces that don't match up
- unexpected behavior
- confusion in the language 

Duplicate concepts: you have two model elements (with implementation details) that represent the same concept. Every time one changes, the other has to also.

False cognates: you have one model element being used in two different ways. Usually this happens when two different people/teams are making changes to the same object, and they have slightly different ideas about what that object should do. This leads to difficult-to-discover bugs.

Continuous Integration

"When a number of people [more than two] are working in the same Bounded Context, there is a strong tendency for the model to fragment...Having defined a Bounded Context, we must keep it sound."

"Sometimes developers do not fully understand the intent of some object or interaction modeled by someone else, and they change it in a way that makes it unusable for its original purpose. Sometimes they don't realize that the concepts they are working on are already embodied in another part of the model and they duplicate (inexactly) those concepts and behavior...It is very hard to maintain the level of communication needed to develop a unified system of any size...We need ways of increasing communication and reducing complexity...We also need safety nets that prevent overcautious behavior..."

"Many SP practices are aimed at this specific problem of maintaining a coherent design that is being constantly changed by many people. XP in its purest form is a nice fit for maintaining model integrity within a single Bounded Context."

"...It is essential to have some process of Continuous Integration...[meaning] that all work within the context is being merged and made consistent frequently enough that when splinters happen they are caught and corrected quickly."

Levels of Continuous Integration:
- The integration of model concepts though communication with team members. Constantly practice your Ubiquitous Language.
- The integration of the implementation through an automated merge/build/test process.

Successful Continuous Integration Processes:
- have a step-by-step, reproducible merge/build technique
- have automated testing suites
- have rules that put an upper limit on how long changes can remain unintegrated
- constantly exercise their Ubiquitous Language in discussions of the model and application

"Continuous Integration is essential only within a Bounded Context. Design issues involving neighboring Contexts, including translation, don't have to be dealt with at the same pace."

Context Map

"When connections must be made between different Contexts, they tend to bleed into each other."

"A Context Map is the overlap between project management and software design."

"The Context Map charts the territory, giving the big picture of the Contexts and their connections...The relationships between a Bounded Context and its neighbors require care and attention...You can reduce confusion by defining the relationship between the different Contexts and creating a global view of all the model contexts on the project."

"The natural course of events is for the boundaries to follow the contours of team organization. People who work closely will naturally share a model context...Physical office space can have an impact too...But the interrelationship between team organization and software model and design is still not prominent enough."

"Code reuse between Bounded Contexts is a hazard to be avoided."

"Identity each model in play on the project and define its Bounded Context. This includes implicit models of non-object-oriented subsystems...Name each Bounded Context, and make the name part of the Ubiquitous Language...Describe the points of contact between the models, outlining explicit translation for any communication and highlighting any sharing...Map the existing terrain. Take up transformations later...Whatever form the map takes, it must be shared and understood by everyone on the project."

"Within each Bounded Context, you will have a coherent dialect of the Ubiquitous Language...You can speak unambiguously about the model of any part of the design by making your Context clear."

"[Don't let necessary repair] lead to wholesale reorganization. Until you have an unambiguous Context Map that places all your work into some Bounded Context, with explicit relationships between all connected models, change only the outright contradictions."

Example: Shipping Application with two Contexts
- a new Bounded Context is created so that a difficult operation can use its own data structures and algorithms
- translations at boundaries should be easily testable, and the teams on each side should collaborate on building the test suite

"Model contexts always exist, but without conscious attention they may overlap and fluctuate."

"Contact points with other Bounded Contexts are particularly important to test...Tests help compensate for the subtleties of translation and the lower level of communication the typically exist at boundaries."

Organizing and Documenting Context Maps
- each Bounded Context should have a name that is part of the Ubiquitous Language
- everyone has to know where the Boundaries are; therefore, everyone will know what Context a piece of code is a part of

Ubiquitous Language example:
- instead of saying "George's team's stuff is changing, so we're going to have to change our stuff that talks to it"
- say "the Transport Network model is changing, so we're going to have to change the translator for the Booking context"

The following are some design patterns for how two Bounded Contexts can relate to each other.

Shared Kernel

A Shared Kernel is a Context that is shared by multiple other Contexts. A common example is an infrastructure framework (created by an internal team) which is used by several other teams. Another common example is the Core Domain.

"Designate some subset of the domain model that the two teams agree to share. Of course this includes, along with this subset of the model, the subset of code or of the database design associated that part of the model. This explicitly shared [kernel] has special status, and shouldn't be changed without consultation with the other team."

"It is a careful balance. The shared kernel cannot be changed as freely as other parts of the design. Decisions involve consultation with another team. Automated test suites must be integrated because all tests of both teams must pass when changes are made."

"The goal is to reduce duplication...and make integration between the two subsystems relatively easy."

Customer/Supplier Development Teams

"Often one subsystem essentially feeds another; the 'downstream' component performs analysis or other functions that feed back very little into the 'upstream' component, and all dependencies go one way...The two subsystems commonly serve very different user communities, who do different jobs, where different models may be useful...Upstream and downstream subsystems separate naturally into two Bounded Contexts."

"Translation is easier for having to operate in one direction only."

Possible problems:
- "The freewheeling development of the upstream team can be cramped if the downstream team has veto power over changes, or if procedures for requesting changes are too cumbersome."
- "The upstream team may even be inhibited, worried about breaking the downstream system."
- "The downstream team can be helpless, at the mercy of upstream priorities."
- "Downstream needs things from upstream, but upstream is not responsible for downstream deliverables."

"The process can be organized to balance the needs of the two user communities and schedule work on features needed downstream...On an XP project, there already is a mechanism in place for doing just that: the iteration planning process...Whatever analogous method serves to balance the concerns of different users can be expanded to include the downstream application's needs."

"Establish a clear customer/supplied relationship between the two teams...In planning sessions, make the downstream team play the customer role to the upstream team...Negotiate and budget tasks for downstream requirements so that everyone understands the commitment and schedule."

"Jointly develop automated acceptance tests that will validate the interface expected...This testing will free the upstream team to make changes without fear of side effects downstream...Automating the acceptance tests is a vital part of this customer relationship."

"The relationship must be that of customer and supplier, with the implication that the customer's needs are paramount...[not] the poor-cousin relationship that often emerges, in which the downstream team has to come begging to the upstream team for its needs."

Example: Yield Analysis vs Booking
- teams using different implementation technologies points you more toward Customer/Supplier than Shared Kernel
- analysis vs operations teams often fall into this Customer/Supplier relationship

"Customer/Supplier teams are more likely to succeed if the two teams work under the same management, so that ultimately they do share goals, or where they are in different companies that actually have those roles."

Conformist

"When two development teams have an upstream/downstream relationship in which the upstream has no motivation to provide for the downstream team's needs, the downstream team is helpless...The downstream project will be delayed until the team ultimately learns to live with what it is given."

Options:
- abandon use of the upstream altogether (go your Separate Ways)
- use the upstream, but develop your own model to fix awkwardness or lack on encapsulation - take full responsibility for the translation (see Anti Corruption Layer)
- use the upstream, and use their model (Conformist)

"Eliminate the complexity of translation between Bounded Contexts by slavishly adhering to the model of the upstream team...Choosing conformity enormously simplifies integration...[And] you will share a Ubiquitous Language with your supplier team."

"It is very unappealing emotionally, which is why we choose it less often than we probably should."

"Where the Shared Kernel is a collaboration between two teams that coordinate tightly, Conformist deals with integration with a team that is not interested in collaboration."

Anti Corruption Layer

"Now we'll take a final step to an even more pessimistic view of the relationship, assuming neither cooperation nor a usable design on the other side..."

"New systems almost always have to be integrated with legacy or other systems, which have their own models. Translation layers can be simple, even elegant, when bridging well-designed Bounded Contexts with cooperative teams...But when the other side of the boundary starts to leak through, the translation layer may take on a more defensive tone."

"The models of legacy systems are usually weak, and even the exception that is well developed may not fit the needs of the current project. Yet there may be a lot of value in the integration, and sometimes it is an absolute requirement."

"The answer is not to avoid all integration with other systems...I've been on projects where people enthusiastically set out to replace all the legacy, but this is just too much to take on at once."

"Integrating with existing systems is a valuable form of reuse."

"When systems based on different models are combined, the need for the new system to adapt to the semantics of the other system can lead to a corruption of the new system's own model...It seems clear enough that errors will result if you take some data from one system and misinterpret it in another."

A common mistake is to assume that you understand how to interpret the data from another system.

"Create an isolating layer to provide clients with functionality in terms of their own domain model. The layer talks to the other system through its existing interface, requiring little or no modification to the other system. Internally, the layer translates in both directions as necessary between the two models."

"The public interface of the Anti Corruption Layer usually appears as a set of Services, although occasionally it can take the form of an Entity."

The other system's model can be completely abstracted, and the Anti Corruption Layer can present an interface perfectly aligned with the current system's model.

See also Facades and Adapters, which do not Translate, but can be useful pieces of an Anti Corruption Layer.
"The Facade belongs in the Bounded Context of the other system. It just presents a friendlier face specialized for your needs."
"An Adapter is a wrapper that allows a client to use a different protocol than that understood by the implementer of the behavior."

Example: Legacy Booking Application
- using an Anti Corruption Layer between new and legacy development, and slower replacing pieces of the legacy system with new development

"Although China might not have become so distinct a culture without the Great Wall, the Wall's construction was immensely expensive and bankrupted at least on dynasty, probably contributing to its fall. The benefits of isolation strategies must be balanced against their costs...There is a time to be pragmatic and make measured revisions to the model, so that it can fit more smoothly with foreign ones."

Separate Ways

"Integration can be very valuable, but it is always expensive. We should be sure it is really needed..."

"We must ruthlessly scope requirements. Two sets of functionality with no indispensable relationship can be cut loose from each other."

Problems with integration:
- coordinating teams
- forced compromises - "The simple specialized model that can satisfy a particular need must give way to the more abstract model that can handle all situations."
- limits technology, based on what can integrate together

"Just because features are related in a use case does not mean they must be integrated."

"Therefore, declare a Bounded Context to have no connection to the others at all, allowing developers to find simple, specialized solutions within this small scope...The features can still be organized in middleware or the UI layer, but there will be no sharing of logic, and an absolute minimum of data transfer through translation layers - preferably none."

Example: An Insurance Project Slims Down
- an overwhelmed project simplifies by identifying features that can be delivered as standalone development, that only comes together in the UI menu

"Taking Separate Ways forecloses some options. Although continuous refactoring can eventually undo any decision, it i shard to merge models that have developed in complete isolation."

Open Host Service

"When a subsystem has to be integrated with many others, customizing a translator for each can bog down the team...If there is any coherence to the subsystem, it is probably possible to describe it as a set of Services that cover the common needs of other subsystems."

"Define a protocol [clean enough to be understood and used by multiple teams] that gives access to your subsystem as a set of Services. Open the protocol so that all who need to integrate with you can use it."

If one subsystem needs to integrate with many other systems that are within your control, flip the relationship so that it is the other subsystems that must integrate with you.

If one team has very specific integration needs, write a custom translator for them, and keep your core protocol simple and clean.

Published Language

"The translation between the models of two Bounded Contexts requires a common language...the translation process itself can become complex and hard to understand."

"When two businesses [or systems] want to exchange information with one another, how do they do it? Not only is it unrealistic to expect one to adopt the domain model of the other, it may be undesirable for both parties."
- "A domain model is developed to solve problems for its users; such a model may contain features that needlessly complicate communication with another system."
- "If the model underlying one of the applications is used as the communications medium, it cannot be changed freely to meet new needs..."
- "Those models may be overly complex or poorly factored."
- "They are probably undocumented."

"The Open Host Service uses a standardized protocol for multiparty integration. It employs a model of the domain for interchange between systems, even though that model may not be used internally by those systems."

#Ch 15: Distillation

#Ch 16: Large-Scale Structure

#Ch 17: Bringing the Strategy Together

#Conclusion
