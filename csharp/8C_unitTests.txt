##Unit Testing

General unit testing topics, not specific to one library

#Test Privates

You can unit test private methods using the PrivateObject.
<code>
using Microsoft.VisualStudio.TestTools.UnitTesting;

public class Apple
{
	public Apple()
	{
	}
	
	private int Count()
	{
		return 5;
	}
}

[TestClass]
public class TestClass
{
	[TestMethod]
	public void TestMethod()
	{
		Apple apple = new Apple();
		PrivateObject privateApple = new PrivateObject(apple);
		
		int result = privateApple.Invoke("Count");
		
		Assert.AreEqual(5, result);
	}
}
</code>

#Test Internals

You can unit test internal classes by marking the original assembly as friendly to the test assembly.

Add this to either the Properties/AssemblyInfo.cs file or to a code file in the assembly.
<code>
using System.Runtime.CompilerServices;
[assembly:InternalsVisibleTo("NameOfFriendAssembly")]
</code>

Marking multiple assemblies as friendly:
<code>
using System.Runtime.CompilerServices;
[assembly:InternalsVisibleTo("NameOfFriendAssemblyA")]
[assembly:InternalsVisibleTo("NameOfFriendAssemblyB")]
//or
[assembly:InternalsVisibleTo("NameOfFriendAssemblyA"), InternalsVisibleTo("NameOfFriendAssemblyB")]
</code>

#Isolation Patterns

You want to keep unit tests isolated from each other, so the order in which they are run does not matter
I've used at least one unit test library that promised to manage isolation when using a shared init/setup method, but it was a lie, so for my own sanity I just manage this myself now

Do Not use a shared Init/Setup method that runs automatically before each test.

Do Not use non-constant global shared variables.

Do write an Init/Setup method that you call explicitly from each test. This gives you control over when to call it, and it is easy to make several setup methods that handle different details.

Do write setup methods that return the data they initialized for use within the test.

Do write a setup method that does the full setup for the Happy Path test.  The Happy Path test just calls this setup and verifies the results.  Then have the Unhappy Path tests call the setup, edit just the part that needs editing to make the test fail, and verify the results.  This focuses attention on what varies between each test, and the Happy Path test confirms that the shared setup method does create a valid data state.

Do write Assistant classes. The test instantiates an Assistant.  The Assistant class holds data initialized for the test, and has methods that handle different steps of the tests.  This makes each test case more legible - it reads as a few method calls instead of all the internal details.  Because each test instantiates its own Assistant, their data is isolated.

#Scripts

These are tricky unit test setups I've had to figure out.

Testing an Asp.Net Core Model Binder
<code>
using System.Collections.Generic;
using System.Globalization;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.Extensions.Primitives;
using Xunit;

//Arrange
var context = new DefaultModelBindingContext()
{
	ModelName = "MyModel",
	ValueProvider = new CompositeValueProvider(new List<IValueProvider>()
	{
		new QueryStringValueProvider(
			new BindingSource("id", "displayName", isGreedy: false, isFromRequest: true),
			new QueryCollection(new Dictionary<string, StringValues>() {
				{ "Test", new StringValues("12") }
			}),
			CultureInfo.DefaultThreadCurrentCulture)
	})
};

//Act
await _modelBinder.BindModelAsync(context);

//Assert
Assert.True(context.Result.IsModelSet);
var filterCriteria = Assert.IsType<MyModel>(context.Result.Model);
Assert.NotNull(filterCriteria);
</code>

If you need an HttpResponseHeaders object for testing, you can get it by instantiating an HttpResponseMessage.
If you need an HttpContent from an object, see these children of HttpContent:
- ByteArrayContent, FormUrlEncodedContent, StringContent, MultipartContent, ReadOnlyMemoryContent, StreamContent, JsonContent
<code>
HttpContent example = JsonContent.Create(new MyObject());
</code>

Given a real Controller, how to mock its HttpContext?
<code>
public void SetupControllerContext(Controller controller, string bearerToken)
{
	var headerCollection = new Mock<IHeaderDictionary>();
	headerCollection.Setup(m => m[ProblemDetailsController.HEADER_AUTHORIZATION]).Returns(bearerToken);
	headerCollection.Setup(m => m.ContainsKey(It.IsAny<string>())).Returns(true);
	var request = new Mock<HttpRequest>();
	request.SetupGet(x => x.Headers).Returns(headerCollection.Object);
	var httpContext = new Mock<HttpContext>();
	httpContext.SetupGet(x => x.Request).Returns(request.Object);
	var context = new ActionContext(httpContext.Object, new RouteData(), new ControllerActionDescriptor());
	controller.ControllerContext = new ControllerContext(context);
} 
</code>