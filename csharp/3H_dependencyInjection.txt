##Dependency Injection

(These notes were last updated for C#12)

#About

Dependency Injection is a design pattern to separate the concrete implementations of interfaces (contracts) from their usage.
For example, a class that makes database queries can have a dependency on an interface that handles the database details. It does not need a code-dependency on the concrete class that specifies how the interface is implemented for SQl Server or for Postgres.
DI is a necessary prerequisite for Inversion Of Control and/or Dependency Inversion.
(I've heard some variety in definitions of those terms, the sources I trust most use this one)
- Inversion Of Control: have high-level modules not rely on low-level modules, have them rely on intefaces instead. The interface can reside on either side of a module-divide, depending on which one you want to be dependent on the other.

In DI, instead of constructing (instantiating) the objects you need, you require that they are passed into the class's constructor or methods.  The depenency (the object you need) must be injected.
Manually (or explicitly) instantiating and passing in the required dependencies is Dependency Injection.  Having C# handle the details automatically is a nice "extra" but is not required for the pattern.

#Dependency Injection Container

You can end up with deep dependency trees. This is common and expected in large Solutions.
C# helps to manage instantiating all those dependencies automatically.

Install NuGet package Microsoft.Extensions.Hosting

Getting started example:
<code>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

// BUILDING PHASE or REGISTRATION PHASE - building the container
using var host = Host.CreateDefaultBuilder(args)
	.ConfigureServices((context, services) => {
		// add registrations here
		// registration order does NOT matter
		services.AddTransient<MyClassA>();
		services.AddTransient<IOperationB, MyClassB>();
	});
	.Build();
	
// RESOLVING PHASE - can get instances of dependencies from container
var myclassa = host.Services.GetRequiredService<MyClassA>();
var operationb = host.Services.GetRequiredService<IOperationB>(); //will return a concrete instance of MyClassB
</code>

With the dependency injection container, you can instantion a class with one simple command even if it has several dependencies, and each of those has several dependencies, etc
as long as /all/ those types are registered with the container, it will automatically instantiate everything needed.

All services registered with the container must have a constructor that is either parameterless, or all its parameter types are also registered with the container.
And there can't be any dependency loops.

Terminology: Service Type, Implementing Type
<code>
// here, the Service Type is "IOperationB"
// and the Implementing Type is "MyClassb"
services.AddTransient<IOperationB, MyClassB>();

// when both are the same Type, you only need to list it once
services.AddTransient<MyClassA>();
</code>
The Implementing Type must implement the Service Type (for example, be an implementation of an interface)

"AddTransient" vs "TryAddTransient"
- "Try" will not overwrite types that have already been registered, if they are registered a second time

a common way to organize a long list of service registrations
<code>
public static class DiRegistrations
{
	public static IServiceCollection RegisterAccounting(this IServiceCollection services) {
		services.TryAddTransient<ClientService>();
		services.TryAddTransient<BankingService>();
		services.TryAddTransient<SettlementService>();
		return services;
	}
	
	public static IServiceCollection RegisterAuditing(this IServiceCollection services) {
		services.TryAddTransient<ClientService>();
		services.TryAddTransient<DisplayService>();
		services.TryAddTransient<CalculationsService>();
		return services;
	}
}

using var host = Host.CreateDefaultBuilder(args)
	.ConfigureServices((context, services) => {
		services.RegisterAccounting();
		services.RegisterAuditing();
	});
	.Build();
</code>

#Lifetimes

Service Lifetime:
Defines when the container should instantiate a new instance of the Implementing Type, or simply return the instance it already has in memory.
<code>
services.AddTransient<MyClassA>();
services.AddSingleton<MyClassA>();
services.AddScoped<MyClassA>();
</code>
Use transient for classes that should be instantiating new each time the container resolves them.
Use singleton for classes that should be instantiating only ONCE for as long as the container exists.
Use scoped for classes that should be instantiated once per scope.

Scopes: You can create multiple scopes under one dependency container to manage when a new service instance is instantiated.
<code>
services.AddScoped<IOperationB, MyClassB>();

using var scopeA = hose.Services.CreateScope();
var instanceA1 = scopeA.ServiceProvider.GetRequiredService<IOperationB>();
</code>
You can also let your services create scopes as they need to:
<code>
public class MyClassC
{
	private readonly IServiceScopeFactory _serviceScopeFactory;
	
	public MyClassC(IServiceScopeFactory serviceScopeFactory) // this dependency is injection by the dependency container
	{
		_serviceScopeFactory = serviceScopeFactory;
	}
	
	public void DoOperation() 
	{
		using var scope = _serviceScopeFactory.CreateScope();
		var myClassB = scope.ServiceProvider.GetRequiredService<IOperationB>();
	}
}
</code>

#Dependency Captivity

Dependency Captivity:
- Given a Singleton service that has a dependency on a Scoped service => de facto, all dependencies of Singleton services are also treated as Singleton.
<code>
using var host = Host.CreateDefaultBuilder(args)
	.UseDefaultServiceProvider((context, options)) =>
	{
		options.ValidateScope = true; //check for some Dependency Captivity errors - will generate a build error
	})
	.ConfigureServices...
</code>
In general, set up your dependency tree so that shorter lifetimes only depend on same or longer lifetimes.

#Service Locator Pattern

Service Locator Pattern: directly resolving services on the dependency container. I.E. calling ServiceProvider.GetRequiredService explicitly.
- This is not recommended.

in other words, instead of passing in dependencies (services), you pass in the DI container itself and let the lower level code get any services it wants to

in this pattern, the DI Container is the "Service Locator"

one big reason this pattern is discouraged is that it makes automated testing harder - you can't just pass a Mocked dependency into a class to test it

#Registering Implementations

This is about using the .Net ServiceProvider class as a Dependency Injection container.

<code>
public interface IMyInterface {}

public class MyImplementation : IMyInterface {}

//setup
using Microsoft.Extensions.DependencyInjection;
public void ConfigureServices(IServiceCollection services)
{
	services.AddScoped<IMyInterface, MyImplementation>();
}

//example usage: Web API
public class MyController : Controller
{
	//this argument is automatically provided by the CLR with the appropriate concrete type
	public MyController(IMyInterface myInterface)
	{
	}
}
</code>

#IOptions

further reading can be done about patterns for using IOptions to inject settings/options/configurations into services, just the ones needed by that service

#Registering Multiple Implementations

Scenario: you have multiple implementations of an interface, and each should be used in different places in your code.

"They will be returned in the same order they are registered in when injected into calling code. Depending on your requirements, this may be useful and important."

<code>
public interface IMyInterface {}

public class AImplementation : IMyInterface {}

public class BImplementation : IMyInterface {}

//setup
using Microsoft.Extensions.DependencyInjection;
public void ConfigureServices(IServiceCollection services)
{
	services.AddScoped<IMyInterface, AImplementation>();
	services.AddScoped<IMyInterface, BImplementation>();
}

//example usage: Web API
using System.Linq;
public class MyController : Controller
{
	//this argument is automatically provided by the CLR with the appropriate concrete type
	public MyController(IEnumerable<IMyInterface> myInterfaces)
	{
		BImplementation b = myInterfaces[1] as BImplementation;
		//or to be less fragile
		BImplementation b = myInterfaces.OfType<BImplementation>().First();
		//or even better, using a method on your IMyInterface
		IMyImplementation x = myInterfaces.First(CanHandle("this operation"));
	}
}
</code>

Asking for one vs multiple:
<code>
// gets the full list of types
public MyController(IEnumerable<IMyInterface> myInterfaces)

// gets just the last-registered type - I recommend not relying on this
public MyController(IMyInterface myInterfaces)
</code>

#Optional Services

Instead of specifying one concrete service to instantiate when an interface is requested,
you can provide a method that decides what service (if any) to return
<code>
services.AddTransient<ICalculator>((serviceProvider) => {
	return new MyCalculator();
});
</code>
If returning a null is possible here, use a Null Implementation instead
- write an implementation of ICalculator that is all 'no-op' - makes no changes to anything, no operation
- and return that as the default

Or you can request a list of services and check if it is empty, or select one from it
<code>
public MyController(IEnumerable<IMyInterface> myInterfaces) {
	if(myInterfaces.IsEmpty()) {
		// do a default operation
	}
	else {
		myInterfaces.First().DoOperation();
	}
}
</code>
