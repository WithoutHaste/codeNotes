##Members

#Field

a variable declared directly in a class or struct
see Instance Fields vs Static Fields

#Property

<code>
public int Name
{
	get; //get accessor
	set; //set accessor
}
</code>
special methods called accessors provide a flexible mechanism to read and write data

TODO: verify this
By default, the private field linked to "Name" is "_name".
You can reference these implicit private fields, like "public int Age { get => _age; set => _age = value; }"

As of C# 7, property accessors can be expression bodied:
<code>
private string name;
public string Name
{
	get => name;
	set => name = value.ToUpperCase();
}
</code>

(.Net 9)

Init Only Setters
For properties (and indexers) that are set only during initialization, and cannot be modified after that.
<code>
public class MyClass
{
	public int X { get; init; } //get accessor and init accessor
    public int Y { get; init; }
}

var myInstance = new MyClass() { X = 1, Y = 2 }; //X and Y are readonly after this
</code>

#Method

functions specific to a class

To get reflection information:
<code>
using System.Reflection;

public class MyType 
{ 
	public void MyMethod() { }
}

//within method...
Type type = typeof(MyType);
MethodInfo methodInfo = type.GetMethods()[0];
</code>

As of C# 6.0 or 7.0, you can format a method as an expression body:
<code>
//with expression body
public class Foo
{
	public string Name { get; }
	public string Age { get; }
	
	public Foo(string name, int age) => (Name, Age) = (name, age);
}
//with block body
public class Foo
{
	public string Name { get; }
	public string Age { get; }
	
	public Foo(string name, int age)
	{
		Name = name;
		Age = age;
	}
}
</code>

#Local Function

As of C# 7, you can declare functions inside other methods.
The inner Local function is only avaliable to the outer method.

Example of separating validation code from implementation code:
<code>
public static IEnumerable<char> AlphabetSubset(char start, char end)
{
	if (start < 'a' || start > 'z')
		throw new ArgumentOutOfRangeException(paramName: nameof(start), message: "start must be a letter");
	if (end < 'a' || end > 'z')
		throw new ArgumentOutOfRangeException(paramName: nameof(end), message: "end must be a letter");	
	if (end <= start)
		throw new ArgumentException($"{nameof(end)} must be greater than {nameof(start)}");
	
	return alphabetSubsetImplementation();
	
	IEnumerable<char> alphabetSubsetImplementation()
	{
		for (var c = start; c < end; c++)
			yield return c;
	}
}
</code>

Example of ensuring that exceptions from validation are thrown before asynchronous work begins:
<code>
public Task<string> PerformLongRunningWork(string address, int index, string name)
{
	if (string.IsNullOrWhiteSpace(address))
		throw new ArgumentException(message: "An address is required", paramName: nameof(address));
	if (index < 0)
		throw new ArgumentOutOfRangeException(paramName: nameof(index), message: "The index must be non-negative");
	if (string.IsNullOrWhiteSpace(name))
		throw new ArgumentException(message: "You must supply a name", paramName: nameof(name));
	
	return longRunningWorkImplementation();
	
	async Task<string> longRunningWorkImplementation()
	{
		var interimResult = await FirstWork(address);
		var secondResult = await SecondStep(index, name);
		return $"The results are {interimResult} and {secondResult}. Enjoy.";
	}
}
</code>

See Lambda Expressions for similar functionality.
	
#Event

publisher classes raise events to alert subscriber classes
	
#Operator

such as + ++ - * / ?: new

#Indexer

aka Smart Array

allows a class to be indexed like an array
resembles a Property
<code>
public int this[int i]
{
	get;
	set;
}
</code>

Indexes can accept a variety of parameters. You can overload indexers by using different parameter lists in the same object.

<code>
public class MyClass<T>
{
	private List<T> list = new List<T>();
	private Dicationary<string, T> dictionary = new Dicationary<string, T>();
	
	public T this[int key]
	{
		get 
		{
			return list[key];
		}
	}
	
	public T this[int row, int column]
	{
		get 
		{
			return list[row][column];
		}
	}
	
	public T this[string key]
	{
		get
		{
			return dictionary[key];
		}
	}
	
	public T this[params string[] keys]
	{
		get
		{
			return //something that uses multiple string keys
		}
	}
}
//calling the indexors
MyClass<Object> myClass = new MyClass<Object>();
Object a = myClass[5];
Object b = myClass["name"];
Object c = myClass["a", "b", "c"];
</code>
	
#Constructor

special functions called on class instantiation
Constructors do not have a return type
<code>
Customer() { }
</code>

Constructor chaining to a base-type constructor:
<code>
class A
{
	public A(int x) 
	{
		//handle x
	}
}
class B : A
{
	public B(int x, int y) : base(x)
	{
		//handle y
	}
}
</code>

Constructor chaining to another constructor in this type:
<code>
class A
{
	public A(int x) : this(x, defaultY)
	{
	}
	public A(int x, int y)
	{
		//handle x and y
	}
}
</code>

As of C# 7, constructors can be expression bodied:
<code>
class A
{
	public int X { get; set; }
	public int Y { get; set; }
	
	public A(int x, int y) => (X, Y) = (x, y);
}
</code>

#Primary Constructor

(.Net 12)

Any parameters in the primary constructor are automatically in-scope for the whole type.
A primary constructor indicates that these parameters are necessary for any instance of the type.

(class, record class) The implicit parameterless constructor isn't emitted when a primary constructor is present.
(struct, record struct) The implicit parameterless constructor is always emitted, and always initializes all fields, including primary constructor parameters, to the 0-bit pattern.

If there is a primary constructor, its parameter list is defined in the class declaration line.
Primary constructors are synthesized from this syntax.
<code>
public class NamedItem(string name)
{
	public string Name => name;
}
</code>

Any explicitly written constructor must use the "this(...)" initializer syntax to invoke the primary constructor. Even an explicit parameterless constructor must invoke the primary constructor.

Calling a parent class's primary constructor
<code>
public class Widget(string name, int count) : NamedItem(name)
{
	public Widget() : this("N/A", 1) {}

	public int Count => count;
}
</code>

Add attributes to the primary constructor
<code>
[method: MyAttribute]
public class MyClass(string name)
{
}
</code>

Add attribute to a positional parameter.
Add xml comments to a positional parameter.
<code>
/// <summary>
/// Person record type
/// </summary>
/// <param name="FirstName">First Name</param>
/// <param name="LastName">Last Name</param>
public record Person(
	[property: JsonPropertyName("firstName")] string FirstName, 
    [property: JsonPropertyName("lastName")] string LastName
	);
</code>

If you don't want to use the auto-generated Property based on the Positional Parameter,
then you can define your own Property that matches the naming convention, 
and is initialized to the Positional Parameter value.
<code>
public record Person(string FirstName, string LastName, string Id)
{
	internal string Id { get; init; } = Id;
}
</code>

#Static Constructor

Special function called only once per type, either automatically before the first instance is created, or automatically before the first static method is called. The static constructor can initialize static fields, or run other one-time operations.
<code>
class A
{
	static A(int x)
	{
	}
	public A(int y)
	{
	}
}
</code>

#Destructor / Finalizer

a special function to destruct a class
only one allowed per class
Destructors cannot be called, they are invoked automatically
the Destructor implicitly calls Finalize on the object's base class
Destructors do not have a return type
<code>
~Customer() { }
</code>

As of C# 7, destructors can be expression bodied:
<code>
~Customer() => Console.WriteLine("Finalized");
</code>

#Nested Type

a class or struct declared inside another class
the inner class can only be used by the outer class

#Deconstructor

C# 7 and above.

This pattern provides Type-to-Tuple conversion.

You can define multiple Deconstruct methods for a Type.
The deconstructor used will depend on the tuple it is being assigned to.

<code>
public class Person
{
	public int Age { get; set; }
	public string Name { get; set; }
	public string Title { get; set; }
	
	//constructor
	public Person(int age, string name, string title)
	{
		Age = age;
		Name = name;
		Title = title;
	}
	
	//deconstructor
	public void Deconstruct(out int age, out string name)
	{
		age = Age;
		name = Name;
	}
	
	//deconstructor
	public void Deconstruct(out int age, out string name, out string title)
	{
		age = Age;
		name = Name;
		title = Title;
	}
}

var person = new Person(23, "Smith", "Engineer");
var (age1, name1) = person;
var (age2, name2, title2) = person;
</code>

Deconstrutors can be added as Extension Methods.

Deconstructor as expression:
<code>
	public void Deconstruct(out int age, out string name, out string title) =>
		(age, name, title) = (Age, Name, Title);
</code>

##C# 6.0 One-Liners
	
#Auto Property Initializers

Succinct read-only property initialization.

As of C# 6.0 (.Net Framework 4.6)

<code>
public string Name { get; } = "Steven";

public DateTime Timestamp { get; } = new DateTime();

public int Id { get; } = NextId();
</code>

#Expression Bodied Methods

Succinct one-line methods.

As of C# 6.0 (.Net Framework 4.6)

<code>
Public override string ToString() => string.Format("{0} {1}", X, Y);
</code>

#Expression Bodied Properties

Succinct one-line read-only properties.

As of C# 6.0 (.Net Framework 4.6)

<code>
Public int Area => Width * Height;
</code>

##Access Modifiers

Access modifiers can be used on members and types (classes, structs, interfaces).

#public

Accessible to the current assembly and any assembly referencing it

#private

Accessible to the same class or struct.
One instance of the class will have access to private members of another instance of the same class.

#protected

Accessible to the same class or struct, and to any class directly derived from this one.

Only accessible to other classes when referrenced through a derived type.
<code>
class A 
{ 
	protected int x = 5; 
}

class B : A 
{ 
	public B() 
	{ 
		x = 6; //valid
	} 
}

class C
{
	public static void Main()
	{
		A a = new A();
		B b = new B();
		
		a.x = 10; //INVALID
		b.x = 10; //valid
	}
}
</code>

#internal

Accessible to the current assembly only

#protected internal

Accessible to the current assembly, and to any class directly derived from this one in another assembly

#private protected

(.Net 7.2)

Accessible to the current assembly, only by the containing class and derived classes

##Other Modifiers

#abstract class

A class that cannot be instantiated, it can only be derived from.

Classes are either abstract or concrete. (Concrete classes don't have a special keyword, they just lack the abstract keyword.)

#abstract method

A method signature with no implementation that must be defined in the derived class
Only valid in abstract classes

#sealed class

Class cannot be inherited from

#new

Explicitly hides a member inherited from a base class, when that member was not virtual

#override

Defines a new implementation of an inherited virtual member

#virtual

Marks that a member may be overriden in a derived class

#static member

A member that belongs to the type instead of to an instance of the type

#static class

A class that cannot be instantiated, but whose static members can be accessed
All members of the class must also be static
The class is implicitly sealed

#const

immutable values known at compile time
only built-in types (primitives + Objects) can be declared as Constants
constants are implicitly also static
constant values can only be set when they are declared
	
#readonly

A field that can only be set (once) in a Constructor or where the field is declared
This field cannot be set in a derived class

#extern

A method that is implemented externally, such as in another assembly

#partial

Allows the definition of a class, struct, or interface to be spread across several files

#implicit

Declare an implicit user-defined type conversion.
<code>
class MyType
{
	private string term;
	private string description;
	
	public static implicit operator string(MyType a)
	{
		return a.ToString();
	}
	
	public override string ToString()
	{
		return term + ": " + description;
	}
}
</code>

#explicit

Declare an explicit user-defined type conversion. (You cannot define both an implicit and explicit conversion between the same two types)
<code>
class MyType
{
	private string term;
	private string description;
	
	public static explicit operator string(MyType a)
	{
		return a.ToString();
	}
	
	public override string ToString()
	{
		return term + ": " + description;
	}
}
</code>

#unsafe

Any block of code that uses pointers must be marked unsafe.

Unsafe code is unverifiable code.
Strong typing cannot be verified by the CLR when using pointer arithmetic.
It is the programmers job to ensure they do not introduce security risks or pointer errors.

Well written pointer operations can increase application performance.

The assembly will need to be compiled with the "-unsafe" option.

You can use unsafe on a Type declaration or a Member.

Marking a method:
<code>
unsafe static void MyMethod()
{
}
</code>

Marking a block of code:
<code>
unsafe
{
}
</code>

#record

(.Net 9)

record modifier can be added to a reference type

While records can be mutable, they're primarily intended for supporting immutable data models.
Benefits
- Concise syntax for creating a reference type with immutable properties
- Built-in value equality, concise syntax for non-destructive mutation, formatting for display
- Support for inheritance hierarchies

Reference Type
<code>
record class... //synonym to clarify a reference type
//can be simplified to just "record"
public record Person(string FirstName, string LastName);

public record Person
{
	public required string FirstName { get; set; }
	public required string LastName { get; set; }
};
</code>

Value Type
<code>
record struct... //define a value type with similar functionality

public readonly record struct Point(double X, double Y, double Z);

public record struct Point
{
	public double X { get; init; }
	public double Y { get; init; }
	public double Z { get; init; }
}
</code>

Positional properties are immutable in a record class and a readonly record struct. They're mutable in a record struct.

When you declare a primary constructor on a record, the compiler generates public properties for the primary constructor parameters.
The primary constructor parameters to a record are referred to as positional parameters.
The compiler creates positional properties that mirror the primary constructor or positional parameters.

Example of that concise syntax
<code>
public record Person(string FirstName, string LastName);

public static void Main()
{
	Person person = new("Jane", "Smith"); //this is Positional Syntax For Property Definition
	Console.WriteLine(person); // "Person { FirstName = Jane, LastName = Smith }"
}
</code>

#required

(.Net 11)

required can modify a Field or Property
required members must be initialized when the object is initialized
- they can be initialized to Null if Null is an allowed value for that member

required cannot be applied to Interface members
but it can be used in class, struct, record class, and record struct

required members must be at least as visible as their containing type

derived types that override a required member must keep it required

Derived types can add the required modifier when overriding a property.
- This surprises me because it would break the Liskov Substitution principle - a derived type could require more properties be initialized than the base type...but if the base type has constructors with fewer params than the derived type then the derived type would already have default initialization for the extra fields in place...so ok this should be ok

A type with any required members may not be used as a type argument when the type parameter includes the "new()" constraint. The compiler can't enforce that all required members are initialized in the generic code.
