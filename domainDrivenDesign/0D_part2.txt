##Part 2

#Preface: The Building Blocks of Model Driven Design

"Certain kinds of decisions keep the model and implementation aligned with each other, each reinforcing the other's effectiveness. This alignment requires attention to the details of individual elements."

"The design style in this book largely follows the principle of Responsibilty Driven Design...and Design By Contract."

"Elaborate models can cut through complexity only if care is taken with the fundementals, rsulting in detailed elements that the team can confidently combine."

#Ch 4 Isolating the Domain

"The part of the software the specifically solves problems from the domain usually constitutes only a small portion of the entire software system...We need to decouple the domain objects from other functions of the system, so we can avoid confusing the domain concepts with other concepts related only to software technology or losing sight of the domain altogether in the mass of the system."

See Layered Architecture / Onion Architecture / Clean Architecuture.
Briefly, isolate the domain logic and don't make it dependent on any other part of the system.

Discussion of when it is appropriate to not use Layered Architecture: fast, simple projects with non-expert developers. See Smart UI Pattern.

#Ch 5 A Model Expressed in Software

"Associations between objects are simple to conceive and to draw, but implementing them is a potential quagmire...Associations illustrate how crucial detailed implementation decisions are to the viability of a Model Driven Design."

Patterns of model elements:
- Value Object
- Entity
- Service

An Entity has a identity that has continuity even as the state of the object changes, even if all its data changes. An Entity's identity may stretch across multiple systems and representations.

A Value Object merely describes an attribute, a value. They could all be immutable without affecting the system.

Services express actions or operations. Services perform operations upon request. These are the operations that don't make sense inside your Entities or Value Objects. These operations need to be done, but they don't correspond with State.

"A sense of the basic principles will help developers stay on course through the inevitable compromises."

Design Principle: "For every traversable association in the model, there is a mechanism in the software with the same properties."

"It is important to restrain relationships as much as possible...In real life, there are lots of many-to-many associations, and a great number are naturally bidirectional. The same tends to be true of early forms of a model as we brainstorm and explore the domain. But these general associations complicate implementation and maintentance. Furthermore, they communicate very little about the nature of the relationship...A bidirectional association means that both objects can be understood only together."

Options to replace a many-to-many relationship:
1) Impose a 1-to-many relationship on it
2) Reduce multiplicity by adding a condition/filter/qualifier to the relationship
3) Remove it entirely if it is non-essential

"This refinement actually reflects insight into the domain, as well as making a more practical design...It captures the understanding that one direction of the association is much more meaningful and important than the other."
Ex: Country <-> President is bidirectional, but we rarely ask "Which country was X president of?" and we rarly say "Y was president of both A and B countries." So we can simplify this relationship to Country -> President.

Entity vs Value Object example:
At a bank, two transactions on the same day, for the same account, for the same amount are Entities because they are distinct from each other despite appearing similar.
The amount of those transactions is a Value Object, because there is no usefullness in distinguishing them from each other or tracking their indentities across time.

Design Principle: Provide all Entities with a way to compare their identity regardless of current state or history. Most commonly, this will be a unique key.

"Identity is not intrinsic to a thing in the world; it is a meaning superimposed because it is useful."

The common theme for these decisions is "what is useful to our purpose?"

"[When modeling Entities,] strip the Entity object's definition down to the most intrinsic characteristics, particularly those that identify it or are commonly used to find or match it. Add only behavior that is essential to the concept and attributes that are required by that behavior. Beyond that, look to remove behavior and attributes into other objects associated with the core Entity...Entities tend to fulfill their responsibilities by coordinating the operations of objects they own."

"[Value Objects] are the objects that describe things...An object that represents a descriptive aspect of the domain with no conceptual identity is called a Value Object...We care about what they are, but not who/which they are."

Example of when an Address is a Value Object: The domain is a mail-order company. It needs your address for your parcel. But if your roommate also places an order, it is not important to realize that the two addresses are the same.

Example of when an Address is an Entity: The domain is an electrical company that runs lines to houses/businesses. They do need to realize that both roommates at the same addresses put in an order. (In this case, maybe the Entity is a "Dwelling" which has a Value Object "Address". There are many ways to organize a domain model.)

Value Objects can be made up of other objects. They do not have to be a primitives like a String or Int.
Value Objects can include references to Entities. Ex: a driving route (Value Object) that links two locations (Entities).
Value Objects are frequently transient (never saved in long-term memory).
Value Objects are frequently attributes of Entities.

"The attributes that make up a Value Object should form a conceptual whole. For example, street, city, and postal code shouldn't be separate attributes of a Person object. They are part of a single, whole Address, which makes a simpler Person, and more coherent Value Object."

Why Value Objects should be Immutable:
- Memory can be conserved by sharing Value Objects without risking data corruption.
  - Ex: PersonA and PersonB share a Name. PersonA edits their Name by instantiating a new Name object, so that PersonB's Name is not affected.
  - A lot of memory can be used up by repeated Value Objects. For instance, imagine every Electrical Outlet in a Floor Plan was a unique object instead of one shared object.
- Value Objects can be passed as arguments without worrying about unintended side effects.
  - Ex: PersonA passes their Name into a method. They know the method will not edit the Name because it cannot.

Not all the constraints we define in the model can be enforced with the programming language we are using. In these cases, you must rely on conventions, good naming standards, and good communication.


#Ch 6 The Life Cycle of a Domain Object