##Building Microservices

Notes from reading "Building Microservices" by Sam Newman.

#Chapter 1: Microservices

Shout out for Eric Evans's "Domain Driven Design": the importance of representing the real world in our code.

Shout out for Alistair Cockburn's Hexagonal Architecture design pattern: guiding us away from layered architectures where business logic can hide.

"Domain driven design. Continuous delivery. On-demand virtualization. Infrastructure automation. Small autonomous teams. Systems at scale. Microservices have emerged from this world."

Microservices are "small, and focused on doing one thing well."

Monolithic codebases generally lose their ideal structures. "Code related to similar functions starts to become spread all over, making fixing bugs or implementations more difficult."
	(I've seen this happen with microservices as well. You can't replace developer discipline with architecture.)
	
"Cohesion - the drive to have related code grouped together...This is reinforced by Robert C. Martin's definition of the Single Responsibility Principle, which states gather together those things that change for the same reason, and separate those things that change for different reasons."

Follow the Single Responsibility Principle by aligning service boundaries with business boundaries. "Making it obvious where code lives for a given piece of functionality."

"How small is small? Jon Eaves characterizes a microservice as something that could be rewritten in two weeks, a rule of thumb that makes sense for his particular context."

"As you get smaller, the benefits around interdependence increase. But so too does some of the complexity that emerges from having more and more moving parts...As you get better at handling this complexity, you can strive for smaller and smaller services."

Rule of thumb is to deploy one service to one machine (or virtual machine). "Although this solution can add some overhead, the resulting simplicity makes our distributed system much easier to reason about."

"All communication between the services themselves are via network calls, to enforce separation between the services and avoid the perils of tight coupling."

Services:
- can be changed independently of each other
- can be deployed without requiring consumers to change

"If there is too much sharing, our consuming services become coupled to our internal representations. This decreases our autonomy."

"Our service exposes an API (application programming interface), and collaborating services communicate with us via those APIs."

"The golden rule: can you make a change to a service and deploy it by itself without changing anything else?"

"With a system composed of multiple, collaborating services, we can decide to use different technologies inside each one."

Regarding using multiple technology stacks: "Just like many things concerning microservices, it's all about finding the right balance."

Example of the scope of microservices: "Gilt, an online fashion retailer, ...today has over 450 microservices, each one running on multiple separate machines."

(A lot of this chapter went straight into the "Strengths" of microservices section)

Indication of microservice size: "How often have you deleted more than a hundred lines of code in a single day and not worried too much about it? With microservices often being of similar size, the barriers to rewriting  or removing services entirely are very low...When a codebase is just a few hundred lines long, it is difficult for people to become emotionally attached to it, and the cost of replacing it is pretty small."

"There is a lack of good consensus on how to do SOA well. In my opinion, much of the industry has failed to look holistically enough at the problem and present a compelling alternative to the narrative set out by various vendors in this space...Many of the problems laid at the door of SOA are actually problems with things like communication protocols (e.g. SOAP), vendor middleware, a lack of guidance about service granularity, or the wrong guidance on picking places to split your system...Much of the conventional wisdom around SOA doesn't hlep you understand how to split something big into something small. It doesn't talk about how big is too big."

"The microservice approach has emerged fro real-world use, taking our better understanding of systems and architecture to do SOA well."

"Technically, it should be possible to create well-factored, independent modules within a single monolithic process. And yet we rarely see this happen. The modules themselves soon become tightly coupled with the rest of the code, surrendering one of their key benefits. Having a process boundary separation does enforce clean hygiene in this respect."

"[Microservices are no silver bullet]...They have all the associated complexity of distributed systems...If you're coming from a monolithic system point of view, you'll have to get much better at handling deployment, testing, and monitoring to unlock the benefits we've covered so far."

The Evolutionary Architect

"Our industry is a young one. This is something we seem to forget, and yet we have only been creating programs that run on what we recognize as computers for around 70 years. Therefore, we are constantly looking to other professions in an attempt to explain what we do...We aren't medical doctors or engineers, but nor are we plumbers or electricians. Instead, we fall into some middle ground, which makes it hard for society to understand us, or for us to understand where we fit."

"Perhaps the term 'architect' has done the most harm. The idea of someone who draws up detailed plans for others to interpret, and expects this to be carried out. The balance of part artist, part engineer, overseeing the creation of what is normally a singular vision, with all other viewpoints being subservient, except for the occasional objection from the structural engineer regarding the laws of physics."

"In our industry, this view of the architect leads to some terrible practices...page after page of documentation, created with a view to inform the construction of the perfect system, without taking into account the fundamentally unknowable future. Utterly devoid of any understanding as to how hard it will be to implement, or whether or not it will actually work, let alone having any ability to change as we learn more."

"Our requirements shift more rapidly than they do for people who design and build buildings - as do the tools and techniques at our disposal."

Since software requirements are always changing, architects need to focus on designing a system that can change.

Comparison of software architecture to city planning, where you can designate zoning rules but you don't specify specifically where or how each building is built.
"Rather than worrying too much about what happens in one zone, the town planner will instead spend far more time working out how people and utilities move from one zone to another."

"We cannot foresee everything that will happen, and so rather than plan for any eventuality, we should plan to allow for change by avoiding the urge to over-specify every last thing."

zones => groups of services (see Domain Driven Design: large-scale structures)
"As architects, we need to worry much less about what happens inside the zone than what happens between the zones."

(aside) "I cannot emphasize how important it is for the architect to actually sit with the team! This is significantly more effective than having a call or just looking at her code...It should be a routine activity."

"Making decisions in system design is all about trade-offs, and microservice architecture gives us lots of trade-offs to make! When picking a datastore, do we pick a platform that we have less experience with, but that gives us better scaling? Is it ok for us to have two different technology stacks in our system? What about three?"

"Framing here can help, and a great way to help frame our decision making is to define a set of principles and practices that guide it, based on goals that we are trying to achieve."

Strategic Goals: high level goals of the business.

Principles: "Principles are rules you have made in order to align what you are doing to some larger goal, and will sometimes change."
"For example, if one of your strategic goals as an organization is to decrease the time to market for new features, you may define a principle that says that delivery teams have full control over the lifecycle of their software to ship whenever they are ready, independently of any other team."
Recommendation: have fewer than 10 principles - it can fit on a poster, people can remember them, they don't contradict each other
!![Example: Heroku's 12 principles for using their platform](http://www.12factor.net)

Constraint: something that is very hard, or impossible, to change.
"Personally, I think there can be some value in keeping [Constraints and Principles] in the same list to encourage challenging constraints every now and then and see if they really are immovable!"

Practices: "Our practices are how we ensure our principles are being carried out. They are a set of detailed, practical guidelines for performing tasks...Low-level enough that any developer can understand them."
Ex: coding guidelines, use HTTP/RESTfor integration, use central logging
"Practices should underpin our principles."

Some standard things services should support:

Monitoring: a system-wide view of the health of our services.
"To make this as easy as possible, I would suggest ensuring that all services emit health and general monitoring-related metrics in the same way."

Interfaces: use one (or very few) interface technologies. This makes is easier to integrate new consumers.
"If you pick HTTP/REST, will you use verbs or nouns? How will you handle pagination of resources? How will you handle versioning of end points?"

Architectural Safety: don't allow one bad service to take down the whole system.

Exemplars: create sample, runnable code that exemplifies the practices you want the team to use.
"Ideally, these would be real-world services you have that get things right, rather than isolated services that are just implemented to be perfect examples...By ensuring that your exemplars are actually being used, you ensure that all principles you have actually make sense."

Tailored Service Template: create service templates that have all the standard stuff already setup.
"You do have to be careful that creating the service template doesn't become the job of a central tools or architecture team who dictates how things should be done, albeit via code. Defining the practices you use should be a collective activity, so ideally your team(s) should take joint responsibility for updating this template."
Ease of use should be the guiding force. Don't build up a framework monstrosity.
Be careful of shared code, which is coupling. Some companies copy-paste the service template instead of using a shared library.

Technical Debt: we can't always get everything done the way we want it immediately, so there is a balance in what we can complete now and what we have to put off until later. How you manage this debt varies from company to company.

Exception Handling: (poorly chosen name - he means making exceptions to principles and practices) Keep track of these exceptions - if enough of the same type stack up, it indicates a change should be made to your practices.

From COBIT (Control Objectives for Information and Related Technology)
"Governance ensures that enterprise objectives are achieved by evaluating stakeholder needs, conditions, and options; setting direction through prioritization and decision making; and monitoring performance, compliance, and progress against agreed-on direction and objectives."

"If one of the architect's jobs is ensuring there is a technical vision, then governance is about ensuring what we are building matches this vision, and evolving the vision if needed."

Architects are responsible for:
- Vision: ensure there are a set of principles derived from the business strategy
- Empathy: ensure they are not making developers miserable; understand the impact of your decisions on your colleagues
- Collaboration: help others grow, get their buy-in, spread the load of leadership
- Adaptability: keep up-to-date with new technologies; change your vision as the situation changes
- Autonomy: find the balance between standardization and letting teams decide
- Governance: ensure the system matches the technical vision; make trade-off decisions

"Normally, governance is a group activity...This group needs to be led by technologist, and to consist predominantly of people who are executing the work being governed. This group should also be responsible for tracking and managing technical risks."

"The architect is responsible for making sure the [governance] group works, but the group as a whole is responsible for governance...This shares the load, and ensures that there is a higher level of buy-in...and that information flows freely from the teams into the group."

What if the group disagrees with the architect?
Author recommends siding with the group. "The group is often much wiser than the individual, and I've been proven wrong more than once! And imagine how disempowering it can be for a group to have been given space to come up with a decision, and then ultimately be ignored."
"But sometimes I have overruled the group. But why, and when?" Comparison to bike riding - it's ok to let the kid fall down, but not to let them veer into traffic.

"Much of the role of the technical leader is about helping grow them [the developers] - helping them understand the vision themselves - and ensuring that they can be active participants in shaping and implementing the vision."

"With larger, monolithic systems, there are fewer opportunities for people to step up and own something. With microservices, on the other hand, we have multiple autonomous codebases that will have their own independent lifecycles. Helping people step up by having them take ownership of individual services before accepting more responsibility can be a great way to help them achieve their own career goals..."

"I am a strong believer that great software comes from great people. If you worry only about the technology side of the equation, you're missing way more than half of the picture."

"The worst reaction to all these forces that push us toward change is to become more rigid or fixed in our thinking."

How to Model Services

What makes a good service? Loose coupling between services and high cohesion within services.

Loose Coupling: "A change to one service should not require a change to another...A loosely coupled service knows as little as it needs to about the services with which it collaborates...Chatty communication can lead to tight coupling."

High Cohesion: "We want related behavior to sit together, and unrelated behavior to sit elsewhere...If we want to change behavior, we want to be able to change it in one place...Making changes in lots of different places is slower, and deploying lots of services at once is risky."

Bounded Context: see Domain Driven Design
A bounded context is like the encapsulation of an object. There are private data and operations inside the boundary. There is a public interface that other services can interact with.
"A specific responsibility enforced by explicit boundaries."
"These bounded contexts lend themselves extremely well to being compositional boundaries...In general, microservices should cleanly align to bounded contexts."

Shared and Hidden Models:
The internal model of a bounded context may well not be the external model it shares with other services.
And models with the same name in different bounded contexts can mean very different things or subtly different things.
"By thinking clearly about what models should be shared, and not sharing our internal representations, we avoid one of the potential pitfalls that can result in tight coupling."

Modules and Services:
"When starting out, keep a new system on the more monolithic side; getting service boundaries wrong can be costly..."
I.e. start with Modules within a monolithic system, and gradually break them out into Services.

Premature Decomposition: anecdote about a team needing to merge all their microservices back into a monolithic system due to unforeseen complications with their CI tool. Then they figured out better boundaries to break it apart on.
- I'm not sure what the CI tool had to do with it.

Business Capabilities: "Ask first 'what does this context do?' and then 'What data does it need to do that?'" Don't determine bounded contexts based on shared data - this is usually incorrect.
"When modeled as services, these [business] capabilities become the key operations that will be exposed over the wire to other collaborators."
From the single responsibility principle, also consider what forces/departments will cause a module/service to have to change.

You may well end up with nested bounded contexts. Maybe the first level determines service boundaries, and the second level determines modules within a service.  Or the second level is also a set of services, but they are entirely hidden behind the first service.

The decision of how and when to break out microservices will often depend on your organization. If a different team is in charge of it, it probably needs to be a separate service.

The decision of how and when to break out microservices can also depend on automated test capabilities.

Communication in Terms of Business Concepts: "If our systems are decomposed along the bounded contexts that represent our domain, the [business] changes we want to make are more likely to be isolated to one, single microservice boundary. This reduces the number of places we need to make the change, and allows us to deploy that change quickly."
"The same terms and ideas that are shared between parts of your organization should be reflected in your interfaces."

"It can be useful to look at what can go wrong when services are modeled incorrectly."
Anecdote about a company that split their service by layers (front end, back end, data access) instead of vertical slices. And also did not abstract business use cases from the backend, they just spoke in low-level database terms everywhere.
"Making decisions to model services boundaries along technical seams isn't always wrong (see performance issues)...However, it should be your secondary driver for finding these seams, not your primary one."

Ch 4: Integration

Avoid breaking changes - changes that force your consumers to change.

Keep your APIs technology-agnostic - technology changes rapidly. Avoid integration technologies that dictate what tech stacks we can use to implement our microservices.

Make you service simple for consumers - freedom on tech choice is good, but providing a client library can ease adoption (but they increase coupling).

Hide internal implementation details - we don't want our consumers to be bound to our internal implementation (that turns more changes into breaking changes).

Interfacing with customers

Shared Database - consumers have direct access to the database
	In short, do not do this. It is the tightest coupling possible.
	Everyone is tied to the exact same model, and to one type of database.
	There is no encapsulation of domain object behavior - each consumer spreads the behavior around.
	
Synchronous VS Asynchronous

"Should communications be synchronous or asynchronous? This fundamental choice inevitably guides us toward certain implementation details."

Synchronous: a call is made to a remote server, which blocks until the operation completes.
	Easier to reason about.
	Enables Request/Response communication.

Asynchronous: the caller doesn't wait for the operation to complete before returning. The caller may not care if the operation ever happens at all.
	Useful for long running jobs.
	Provides low latency. Can keep a UI responsive even when the network is laggy.
	But the technology is more complicated.
	Additional work is required for monitoring/tracking that everything is happening correctly.
	Enables Event-Based communication.
	
Request/Response: a client initiates a request and waits for a response.
	This is usually done synchronously, but can be done asynchronously with callbacks.

Event-Based: a client reports that something has happened, and listeners take action based on that event.
	Business logic spreads out more evenly, rather than being centrally located. This can result in higher cohesion.
	Highly decoupled.
	
Orchestration VS Choreography
	Orchestration: a central system tells others when to run. See Request/Response.
		"Simpler, and we get to know if things worked straight away."
		"Tends to be brittle, with a higher cost of change."
	Choreography: each system decides when to take action. See Event-Based.
		"In general, I have found that systems that tend more towards the choreographed approach are more loosely coupled, and are more flexible and amenable to change."
		"Each service is smart enough to understand it's role in the whole dance."

Remote Procedure Call (RPC)
	Provides Request/Response
	"Refers to the technology of making a local call and having it execute on a remove service somewhere."
	May rely on having an interface definition (see SOAP, Thrift, protocol buffers)
		"The use of separate interface definitions can make it easier to generate client and server stubs for diff tech stacks." (See SOAP with WSDL)
		"Other tech, like Java RMI, calls for a tighter coupling between the client and server, requiring that both use the same underlying technology."
	The core characteristic is that a remove call looks like a local call.
	Ease of use is a selling point.
	Can become coupled to particular technology.
	May hide that a call is remote too much - you need to know what calls will be significantly slower.
	Some RPC solutions are very brittle. Changes to a Java RMI solution are always breaking changes.
	
REpresentational State Transfer (REST)	
	Provides Request/Response
	Usually used over HTTP
	"How a resource is shown externally is completely decoupled from how it is stored internally." - This can be done as badly with REST and with any other architecture. And there is nothing inherent to RPC that makes the public contracts match internal models.
	Uses HTTP verbs in standard ways - easier to learn a new interface.
	HTTP is well supported with many tools.
	Downside - HTTP is not the most efficient of formats
	
Hypermedia As The Engine Of Application State (HATEOAS)
	An extension of REST
	Resources return links to related resources and actions (state transitions). The links have unchanging semantic labels, which frees the links themselves to change without breaking the consumer.
	"By following the links, the client gets to progressively discover the API, which can be a really handy capability when we are implementing new clients."
	"Using these controls to decouple the client and server yields significant benefits over time that greatly offset the small increase in the time it takes to get these protocols up and running."
	Downside - can be very chatty, as the client crawls through the network of links.
	Downside - not well supported by tools yet - you'll have to roll your own servers and clients
	
JSON, XML, or other
	JSON is very popular right now - succinct, but lacks semantic tags of XML
		Hypertext Application Language (HAL) attempts to add hyperlinking to JSON
	XML is supported by XPath, which allows you to find tags even when they have moved around the data structure - more resilient clients
	
Beware Too Much Convenience
	for example, tools that standup a service quickly by serializing Domain models and sending them out as REST contracts are not good

Asynchronous Event-Based Collaboration
	Choose how services will emit events, and how subscribers will listen for them
	"Traditionally, message brokers like RabbitMQ try to handle both problems."
		Can also keep track of what messages a subscriber has already seen, and handle error queues.
	"These systems are usually designed to be scalable and resilient, but that doesn't come for free. It can add complexity to the development process, because it is another system you may need to run to develop and test your services."
	But once it is running, it can be a very effective solution.
	There are also options like ATOM - but the subscribers have to manage their queues themselves.
	
Complexities of Asynchronous Architectures
	"For example, when considering long-running async request/response, we have to think about what to do when the response comes back. Does it come back to the same node that initiated the request? If so, what if that node is down? If not, do I need to store information somewhere so I can react accordingly?"
	How many times can subscribers attempt to process a message before they should all give up?
	How to manage your error queue?
	What if you have multiple versions of the same message type active at once?
	
Services as State Machines
	"Our customer microservice owns all logic associated with behavior in this context. When a consumer wants to change a customer, it sends an appropriate request to the customer service...Our customer service controls all lifecycle events associated with the customer itself." (See Encapsulation)
	"We want to avoid dumb, anemic services that are little more than CRUD wrappers."
	
Reactive Extensions (Rx)
	"Mechanisms to compose the results of multiple calls together and run operations on them."
	Works with asynchronous communication.
	"At its heart, Rx inverts traditional flows. Rather than asking for some data, then performing operations on it, you observe the outcome of an operation (or set of operations) and react when something changes."
	"They allow us to abstract out the details of how calls are made, and reason about things more easily."
	
DRY and the perils of code reuse in a microservice world
	(see Martin about Single Responsibility meaning "responsible to a single individual/business unit" - one reason to change)
	"DRY more accurately means that we want to avoid duplicating our system behavior and knowledge."
	"When you want to change behavior, and that behavior is duplicated in many parts of your system, it is easy to forget everywhere you need to make a change, which can lead to bugs."
	Shared libraries can be deceptively dangerous in microservices. It is tight coupling.
	"My general rule: don't violate DRY within a microservice, but be relaxed about violating DRY across all services."
	
Client Libraries
	"I've spoken to more than one team who has insisted that creating client libraries for your services is an essential part of creating services in the first place."
	A danger is that business logic will end up in the client library, when it should have stayed in the service. This can happen when the same people code the service and the client library.
	"If the client library approach is something you're thinking about, it can be important to separate out client code to handle the underlying transport protocol, which can deal with things like service discovery and failure, from things related to the destination service itself."
	
Access By Reference
	"We need to embrace the idea that a microservice will encompass the lifecycle of our core domain entities, like the Customer...We should consider the customer service as being the source of truth for Customers."
	Consider how long you can hold cached data before you need to refresh it.
	"Whether you decide to pass around a memory [cache] of what an entity once looked like, make sure you also include a reference to the original resource so that the new state can be retrieved."
	
Versioning

Defer It As Long As Possible
	"The best way to reduce the impact of making breaking changes is to avoid making them in the first place."
	"REST helps because changes to internal implementation detail are less likely to result in a change to the service interface." - Again, nothing in REST does this, it is still down to separating your API contracts from your internal models.
	"Another key to deferring a breaking change is to encourage good behavior in your clients, and avoid them binding too tightly to your services in the first place."
		Example: the client should only deserialize the fields they need, not everything by default.
		Example: a client that can find a field, even when it moves around the data structure, will break less often.
	Postel's Law (aka Robustness Principle): Be conservative in what you do, be liberal in what you accept from others.
	
Catching Breaking Changes Early
	see Consumer-Driven Contracts
	test early and often
	
see Semantic Versioning (Major.Minor.BugFix)
	
Coexist Different Endpoints
	If you add a side-by-side new endpoint, then clients can gradually shift from the old to the new. Then you can remove the old one.
	Expand and Contract Pattern: we expand the capabilities we offer, then contract once all clients are off the old version
	
Use Multiple Concurrent Service Versions
	Run two versions of the service side-by-side and manage the traffic with routing/proxy/whatever
	Downside - you have to support two codebases at once
	
User Interfaces
	Terminal vs Web vs Mobile
	consider data usage and battery usage
	consider how to provide different UIs to Web and Mobile
	API composition
	UI fragment composition
	Backends for frontends

Integrating with 3rd party software
	most companies need software that they do not have time to write and maintain themselves
	"Build if it is unique to what you do, and can be considered a strategic asset; buy if your use of the tool isn't that special."
	you will have little or no control of how 3rd party systems are written, supported, updated, or operated
	you will have little ability to customize 3rd party tools
	it's often a good idea to place a microservice between the 3rd party tool and the rest of your system, to handle all integration
	Strangler Pattern: intercept messages to old system, decide if you want to re-route them to new system
	
Ch 5 Splitting the Monolith ================================

"How do we handle the fact that we may already have a large number of codebases lying about that don't follow these patterns? How do we go about decomposing these monolithic applications without having to embark on a big-bang rewrite?"

cohesion: keep things together that tend to change together

seam: a portion of the code that can be treated in isolation and worked on without impacting the rest of the codebase
"We want to identify seams that can become service boundaries."
- bounded contexts make excellent seams
- most programming languages provide namespace concepts that allow us to group similar code together - can indicate a seam

"We should identify the high-level bounded contexts that we think exist in our organization...Then we want to try to understand what bounded contexts the monolith maps to."
- create packages representing these contexts
- move the existing code into them
- left over code, that doesn't fit any context, will indicate more seams
- you can do this to a small portion of the system, it does not have to be all at once

"Our code should represent our organization, so our packages representing the bounded contexts in our organization should interact in the same way the real-life organizational groups in our domain interact."
- ex: the warehouse code should have no dependency on the finance department code

"I would strongly advise you to chop away at these systems. An incremental approach will help you learn about microservices as you go, and will also limit the impact of getting something wrong."
- where to start, once you have your seams?
- consider which seam will give you the most benefit when it is split into a microservice

Considerations
- pace of change: you know that Inventory Management will be changing rapidly soon
- team structure: you have teams in different time zones - giving them different codebases to work on will help them be independent
- security: one bounded context needs tighter security than the rest
- technology: a team wants to write special algorithms in a specific language for one bounded context
- tangled dependencies: how much unwinding will it take to move this bounded context out of the monolith?

consider how entangled the different parts of your monolith are with one shared database
find seams in the database as you find seams in the codebase
you can start by dividing the database access code into different packages based on the bounded contexts
- watch out for foreign key constraints that cross boundaries

splitting the database will result in more database calls being made, since you can't all your data with a single JOIN
"Typically concerns around performance are now raised. I have a fairly easy answer to this: how fast does your system need to be? And how fast is it now? If you can test its current performance and know what good performance looks like, then you should feel confident in making a change."
"Also, we end up breaking transactional integrity when we move to two schemas..." This will take more thought about the design of the workflows.

Shared Static Data
recommendation to not store static (unchanging or very very rarely changing) data in a database - put it in a resource file instead
- faster lookup times
- self-documents that the data is stable
Other options:
- put the shared data behind it's own service
- copy the shared data into each service that will need it
Both of these are usually over-kill

Shared Mutable Data
this shared data probably needs its own service
or the table is actually two distinct tables glues together, and it can be split with one piece going to each client service, with a foreign key between them

Staging the Break
- found the seams and separated code into different packages, still in the same monolith
- found the database seams and separated those out, too
- now you can pull one piece of code out into a microservice

Transactional Boundaries
transaction: these events either all happen together, or none of them happen
- very useful for keeping data in a consistent state through complex changes
what to do after dividing an operation into multiple transactions?
- Try again later: retry each step of the operation until each has succeeded (see Eventual Consistency)
- Abort entire operation: unwind the transactions that already succeeded (see Compensating Transaction)
- Distributed transactions: a way to NOT split your transaction - can manage multiple normal transactions within one overarching transaction that can cross system boundaries

Distributed Transactions
	Two-Phase Commit: first the voting phase, where each transaction (participant or cohort) says if it thinks its local transaction can complete. if all answer yes, then they are all told to commit. if any say no, they are all told to rollback.
	- vulnerable to outages, where the process is interrupted in the middle, or a cohort cannot respond
	- what if a commit fails after the voting phase?
	- pending transactions will hold locks on resources, which can lead to contention - consider how this affects scaling of systems
	"The various algorithms are hard to get right, so I'd suggest you avoid trying to create your own...Do lots of research on this topic if this seems like the route you want to take..."
	consider the cost of data cleanup vs the cost of catching every edge case
	
"All of these solutions add complexity...Distributed transactions are hard to get right and can actually inhibit scaling...Systems that eventually converge through compensating retry logic can be harder to reason about, and may need other compensating behavior to fix up inconsistencies in data."

"If you do encounter state that really, really wants to be kept consistent, do everything you can to avoid splitting it up in the first place. Try really hard."
"If you really need to go ahead with the split, think about moving from a purely technical view of the process and actually create a concrete concept to represent the transaction itself." (see Making Implicit Domain Models Explicit)

Reporting with one data store
	Even when all the data is already stored in one database (monolithic system), for performance issues, the reporting database is often separate.
	Consider - should the main database and reporting database share the same schema? It makes it easy to mirror data, but you lose the efficiency of designing the reporting database for reporting use cases.
Reporting with many data stores
	"In splitting a service into smaller parts, we need to also potentially split up how and where data is stored...The audience of our reporting systems are users like any other, and we need to consider their needs."
	You can pull the data together using API calls. This works only for small queries.
	Caching data in the reporting database has the usual dangers - the data may be out of date. If you cache on the service side, consider that "the nature of reporting is often that we access the long tail of data. THis means that we may well request resources that no one else has requested before, resulting in a potentially expensive cache miss."
	"Reporting systems also often rely on third-party tools that expect to retrieve data in a certain way, and here providing a SQL interface is the fastest way to ensure your reporting tool chain is as easy to integrate with as possible."
	You may need to write APIs just for reporting purposes. (See Batch APIs) Also consider asynchronous batching: request a bunch of data, ping the system until your export is ready, pick up the file.
Data Pump
	Each service pushes data updates to reporting. 
	Or "a standalone program that directly accesses the database of the service that is the source of data, and pumps it into a reporting database...We try to reduce the problems with coupling to the service's schema by having the same team that manages the service also manage the pump."
Event Data Pump
	You could update reporting with event listeners.  Danger here in coupling separate services.
Maybe you don't need all that data in one place, anyway. Consider distributed reporting.

"Small, incremental changes...allow us to better mitigate the cost of mistakes, but doesn't remove the chance of mistakes entirely."
- small cost: moving code within a codebase
- large cost: splitting a database
- large cost: rolling back a database change
Recommendation - think about and draw out your designs before you start. Consider the principles of object-oriented design, but at the service level.

It's ok for a service to grow so large it needs to be split. That's a cycle. "The key is knowing it needs to be split before the split becomes too expensive."

Deployment ========

Cycle Time: the time it takes to get one change through development all the way to production

Continuous Integration (CI)
	every time code is checked in, the server compiles it and runs tests to verify it is in a valid state
	this requires that you do have a suite of automated regression tests
	"The core goal is to keep everyone in sync with each other."
	if any artifacts are created, they are only created once per version of the code - "This is to avoid doing the same thing over and over again, and so that we can confirm that the artifact we deployed is the one we tested."
	the more frequently you merge changes together, the easier those merges will be
	
Microservices Plus CI
1) you can have 1 repo with all the different services in it
	(con) any checkin causes all the services to rebuild
		this can take awhile - especially running all the regression tests
		it is unclear how many of these services now need to be deployed
	(pro) you can checkin changes to multiple services at one time
	(con) if you break the build, the whole pipeline is dead
	this is not a good long-term solution, but it can get a new project started
2) you can have 1 repo with all the different services in it PLUS configure the CI tool to recognize different folders as different services
	fixes several problems with the last approach
	"On the one hand, my check-in/check-out process can be simpler as I have only one repository to worry about. On the other hand, it becomes very easy to get into the habit of checking in source code for multiple services at once, which can make it equally easy to slip into making changes that couple services together."
3) 1 repo per service, with one CI build per repo

Build Pipelines and Continuous Delivery
	you can specify what order to run build steps in
		ex: run the fast tests first, so if they fail we don't have to run the slow ones at all
	"This build pipeline concept gives us a nice way of tracking the progress of our software as it clears each stage, helping give us insight into the quality of our software."
	
Continuous Delivery (CD)
	"The approach whereby we get constant feedback on the production readiness of each and every check-in, and furthermore treat each and every check-in as a release candidate."
	